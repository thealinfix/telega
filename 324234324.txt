diff --git a/hypebot/__init__.py b/hypebot/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/hypebot/config.py b/hypebot/config.py
new file mode 100644
index 0000000000000000000000000000000000000000..f45891717e45df992704be6e6a6fb62b303567ad
--- /dev/null
+++ b/hypebot/config.py
@@ -0,0 +1,141 @@
+import os
+import logging
+
+TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN") or "–¢–í–û–ô_–¢–ï–õ–ï–ì–†–ê–ú_–¢–û–ö–ï–ù"
+TELEGRAM_CHANNEL = os.getenv("TELEGRAM_CHAT_ID") or "@channelusername"
+ADMIN_CHAT_ID = os.getenv("ADMIN_CHAT_ID") or "123456789"
+OPENAI_API_KEY = os.getenv("OPENAI_API_KEY") or "sk-...."
+STATE_FILE = "state.json"
+CHECK_INTERVAL_SECONDS = 1800
+MAX_PENDING_POSTS = 100
+MAX_POST_AGE_DAYS = 7
+MAX_IMAGES_PER_POST = 10
+DEFAULT_TIMEZONE = "Europe/Moscow"
+
+IMAGE_STYLES = {
+    "sneakers": {
+        "prompt_template": "Modern minimalist sneaker promotional image, {title}, clean background, professional product photography, studio lighting, high quality, 4k",
+        "style": "photographic",
+    },
+    "fashion": {
+        "prompt_template": "Fashion editorial style image, {title}, trendy streetwear aesthetic, urban background, magazine quality",
+        "style": "editorial",
+    },
+    "thoughts": {
+        "prompt_template": "Artistic abstract representation of {topic}, modern digital art, vibrant colors, emotional expression, Instagram story format",
+        "style": "artistic",
+    },
+    "custom": {"prompt_template": "{custom_prompt}", "style": "creative"},
+}
+
+HASHTAGS = {
+    "sneakers": {
+        "nike": "#nike #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–Ω–∞–π–∫ #–Ω–∏–∫–µ–±—É—Ç–∏–∫",
+        "adidas": "#adidas #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–∞–¥–∏–¥–∞—Å #threestripes",
+        "jordan": "#jordan #airjordan #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–¥–∂–æ—Ä–¥–∞–Ω #jumpman",
+        "newbalance": "#newbalance #nb #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–Ω—å—é–±–∞–ª–∞–Ω—Å #madeinusa",
+        "puma": "#puma #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–ø—É–º–∞ #pumafamily",
+        "yeezy": "#yeezy #adidas #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–∏–∑–∏ #kanye",
+        "asics": "#asics #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–∞—Å–∏–∫—Å #geltechnology",
+        "reebok": "#reebok #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #—Ä–∏–±–æ–∫ #classic",
+        "vans": "#vans #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–≤–∞–Ω—Å #offthewall",
+        "converse": "#converse #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–∫–æ–Ω–≤–µ—Ä—Å #allstar",
+        "default": "#sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #streetwear #–æ–±—É–≤—å #sneakerhead",
+    },
+    "fashion": {
+        "supreme": "#supreme #streetwear #fashion #—Å—É–ø—Ä–∏–º #hypebeast",
+        "offwhite": "#offwhite #fashion #streetwear #virgilabloh",
+        "stussy": "#stussy #streetwear #fashion #stussytribe",
+        "palace": "#palace #streetwear #fashion #palaceskateboards",
+        "default": "#fashion #–º–æ–¥–∞ #streetwear #style #—Å—Ç–∏–ª—å #outfit",
+    },
+}
+
+SOURCES = [
+    {
+        "key": "sneakernews",
+        "name": "SneakerNews",
+        "type": "json",
+        "api": "https://sneakernews.com/wp-json/wp/v2/posts?per_page=10&_embed",
+        "category": "sneakers",
+    },
+    {
+        "key": "hypebeast",
+        "name": "Hypebeast Footwear",
+        "type": "rss",
+        "api": "https://hypebeast.com/footwear/feed",
+        "category": "sneakers",
+    },
+    {
+        "key": "highsnobiety",
+        "name": "Highsnobiety Sneakers",
+        "type": "rss",
+        "api": "https://www.highsnobiety.com/tag/sneakers/feed/",
+        "category": "sneakers",
+    },
+    {
+        "key": "hypebeast_fashion",
+        "name": "Hypebeast Fashion",
+        "type": "rss",
+        "api": "https://hypebeast.com/fashion/feed",
+        "category": "fashion",
+    },
+    {
+        "key": "highsnobiety_fashion",
+        "name": "Highsnobiety Fashion",
+        "type": "rss",
+        "api": "https://www.highsnobiety.com/tag/fashion/feed/",
+        "category": "fashion",
+    },
+]
+
+BRAND_KEYWORDS = {
+    "nike": ["nike", "air max", "air force", "dunk", "blazer", "cortez", "vapormax", "pegasus"],
+    "adidas": ["adidas", "yeezy", "boost", "ultraboost", "nmd", "gazelle", "samba", "campus"],
+    "jordan": ["jordan", "air jordan", "aj1", "aj4", "aj11", "jumpman"],
+    "newbalance": ["new balance", "nb", "990", "991", "992", "993", "2002r", "550"],
+    "asics": ["asics", "gel", "gel-lyte", "gel-kayano", "gel-1090"],
+    "puma": ["puma", "suede", "clyde", "rs-x"],
+    "reebok": ["reebok", "classic", "club c", "question"],
+    "vans": ["vans", "old skool", "sk8-hi", "authentic", "era"],
+    "converse": ["converse", "chuck taylor", "all star", "one star"],
+    "salomon": ["salomon", "xt-6", "speedcross"],
+    "supreme": ["supreme", "box logo"],
+    "offwhite": ["off-white", "off white", "virgil abloh"],
+    "stussy": ["stussy", "st√ºssy"],
+    "palace": ["palace", "palace skateboards"],
+}
+
+MODEL_KEYWORDS = {
+    "airmax": ["air max", "airmax", "am1", "am90", "am95", "am97"],
+    "airforce": ["air force", "af1", "air force 1"],
+    "dunk": ["dunk", "dunk low", "dunk high", "sb dunk"],
+    "yeezy": ["yeezy", "boost 350", "boost 700", "foam runner"],
+    "jordan1": ["jordan 1", "aj1", "air jordan 1"],
+    "jordan4": ["jordan 4", "aj4", "air jordan 4"],
+    "ultraboost": ["ultraboost", "ultra boost"],
+    "990": ["990", "990v", "990v5", "990v6"],
+}
+
+RELEASE_TYPES = {
+    "retro": ["retro", "og", "original", "vintage"],
+    "collab": ["collab", "collaboration", "x ", " x ", "partner"],
+    "limited": ["limited", "exclusive", "rare", "special edition"],
+    "womens": ["women", "wmns", "female"],
+    "kids": ["kids", "gs", "gradeschool", "youth"],
+    "lifestyle": ["lifestyle", "casual", "street"],
+    "performance": ["performance", "running", "basketball", "training"],
+}
+
+if not all([TELEGRAM_TOKEN, OPENAI_API_KEY]):
+    logging.critical("–ù–µ –∑–∞–¥–∞–Ω—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è")
+    exit(1)
+
+if ADMIN_CHAT_ID and ADMIN_CHAT_ID != "123456789":
+    try:
+        ADMIN_CHAT_ID = int(ADMIN_CHAT_ID)
+    except ValueError:
+        logging.critical("ADMIN_CHAT_ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
+        exit(1)
+else:
+    ADMIN_CHAT_ID = None
diff --git a/hypebot/fetcher.py b/hypebot/fetcher.py
new file mode 100644
index 0000000000000000000000000000000000000000..fed636a577ced20f4c4191b7ced64809f2423d7d
--- /dev/null
+++ b/hypebot/fetcher.py
@@ -0,0 +1,246 @@
+import logging
+import httpx
+from bs4 import BeautifulSoup, FeatureNotFound
+from urllib.parse import urljoin, urlparse
+from datetime import datetime, timezone
+from typing import List
+
+from . import config, state, utils
+
+
+async def extract_all_images_from_page(client: httpx.AsyncClient, url: str) -> List[str]:
+    images = []
+    try:
+        headers = {"User-Agent": "Mozilla/5.0"}
+        response = await client.get(url, headers=headers, timeout=20, follow_redirects=True)
+        if response.status_code == 200:
+            soup = BeautifulSoup(response.text, "html.parser")
+            base_url = f"{urlparse(url).scheme}://{urlparse(url).netloc}"
+            selectors = [
+                "div.gallery img",
+                "div.post-gallery img",
+                "div.article-gallery img",
+                "div.gallery-container img",
+                "figure img",
+                "div.post-content img",
+                "article img",
+                "div[class*='gallery'] img",
+                "div[class*='slider'] img",
+                "div.entry-content img",
+            ]
+            seen_urls = set()
+            for selector in selectors:
+                for img in soup.select(selector):
+                    img_url = img.get("src") or img.get("data-src") or img.get("data-lazy-src")
+                    if not img_url:
+                        continue
+                    if not img_url.startswith("http"):
+                        img_url = urljoin(base_url, img_url)
+                    if utils.is_valid_image_url(img_url) and img_url not in seen_urls:
+                        if "logo" not in img_url.lower() and "icon" not in img_url.lower():
+                            images.append(img_url)
+                            seen_urls.add(img_url)
+                    if len(images) >= config.MAX_IMAGES_PER_POST:
+                        break
+                if len(images) >= config.MAX_IMAGES_PER_POST:
+                    break
+            logging.info(f"–ù–∞–π–¥–µ–Ω–æ {len(images)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {url}")
+    except Exception as e:
+        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {e}")
+    return images[: config.MAX_IMAGES_PER_POST]
+
+
+async def parse_full_content(client: httpx.AsyncClient, record: dict) -> dict:
+    try:
+        all_images = await extract_all_images_from_page(client, record["link"])
+        if all_images:
+            record["images"] = all_images
+            record["original_images"] = all_images.copy()
+            logging.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–æ {len(all_images)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –ø–æ—Å—Ç–∞ {record['title'][:30]}...")
+        record["needs_parsing"] = False
+    except Exception as e:
+        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª–Ω–æ–º –ø–∞—Ä—Å–∏–Ω–≥–µ: {e}")
+    return record
+
+
+async def fetch_releases(client: httpx.AsyncClient, progress_message=None, bot=None) -> list:
+    headers = {"User-Agent": "Mozilla/5.0"}
+    releases = []
+    seen_titles = set()
+    total_sources = len(config.SOURCES)
+    for idx, src in enumerate(config.SOURCES):
+        try:
+            if progress_message and bot:
+                try:
+                    await bot.edit_message_text(
+                        f"üîÑ –ü—Ä–æ–≤–µ—Ä—è—é –∏—Å—Ç–æ—á–Ω–∏–∫–∏... ({idx + 1}/{total_sources})\n"
+                        f"üìç –°–µ–π—á–∞—Å: {src['name']}",
+                        progress_message.chat.id,
+                        progress_message.message_id,
+                    )
+                except Exception:
+                    pass
+            logging.info(f"–ü—Ä–æ–≤–µ—Ä—è—é –∏—Å—Ç–æ—á–Ω–∏–∫: {src['name']}")
+            resp = await client.get(src["api"], headers=headers, timeout=20)
+            resp.raise_for_status()
+            if src["type"] == "json":
+                try:
+                    posts = resp.json()
+                    if not isinstance(posts, list):
+                        logging.warning(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö –æ—Ç {src['name']}")
+                        continue
+                except Exception:
+                    continue
+                for post in posts[:10]:
+                    try:
+                        link = post.get("link")
+                        title_data = post.get("title", {})
+                        title = (
+                            title_data.get("rendered", "") if isinstance(title_data, dict) else str(title_data)
+                        )
+                        title = BeautifulSoup(title, "html.parser").get_text(strip=True)
+                        if not link or not title or len(title) < 10:
+                            continue
+                        title_key = title.lower().strip()
+                        if title_key in seen_titles:
+                            continue
+                        seen_titles.add(title_key)
+                        uid = utils.make_id(src["key"], link)
+                        if uid in state.state["pending"] or link in state.state["sent_links"]:
+                            continue
+                        date_str = post.get("date") or post.get("modified")
+                        pub_date = (
+                            datetime.fromisoformat(date_str.replace("Z", "+00:00"))
+                            if date_str
+                            else datetime.now(timezone.utc)
+                        )
+                        images = []
+                        media = post.get("_embedded", {}).get("wp:featuredmedia", [])
+                        if media and isinstance(media, list) and len(media) > 0:
+                            featured_url = media[0].get("source_url")
+                            if featured_url and utils.is_valid_image_url(featured_url):
+                                images.append(featured_url)
+                        context = ""
+                        releases.append(
+                            {
+                                "id": uid,
+                                "title": title[:200],
+                                "link": link,
+                                "images": images,
+                                "original_images": images.copy(),
+                                "context": context[:500] if context else "",
+                                "source": src["name"],
+                                "category": src.get("category", "sneakers"),
+                                "timestamp": pub_date.isoformat(),
+                                "needs_parsing": True,
+                                "tags": utils.extract_tags(title, context),
+                            }
+                        )
+                    except Exception:
+                        continue
+            elif src["type"] == "rss":
+                try:
+                    try:
+                        soup = BeautifulSoup(resp.text, "xml")
+                        items = soup.find_all("item")
+                    except FeatureNotFound:
+                        soup = BeautifulSoup(resp.text, "html.parser")
+                        items = soup.find_all("item")
+                    if not items:
+                        items = soup.find_all("entry")
+                    for item in items[:10]:
+                        try:
+                            link = None
+                            link_elem = item.find("link")
+                            if link_elem:
+                                link = link_elem.get_text(strip=True) if link_elem.string else link_elem.get("href")
+                            if not link:
+                                guid = item.find("guid")
+                                if guid and guid.get_text(strip=True).startswith("http"):
+                                    link = guid.get_text(strip=True)
+                            title = None
+                            title_elem = item.find("title")
+                            if title_elem:
+                                title = title_elem.get_text(strip=True)
+                            if not link or not title or len(title) < 10:
+                                continue
+                            title_key = title.lower().strip()
+                            if title_key in seen_titles:
+                                continue
+                            seen_titles.add(title_key)
+                            if src.get("category") == "sneakers":
+                                title_lower = title.lower()
+                                keywords = [
+                                    "nike",
+                                    "adidas",
+                                    "jordan",
+                                    "yeezy",
+                                    "new balance",
+                                    "puma",
+                                    "reebok",
+                                    "vans",
+                                    "converse",
+                                    "asics",
+                                    "sneaker",
+                                    "shoe",
+                                    "footwear",
+                                    "release",
+                                    "drop",
+                                    "collab",
+                                    "air max",
+                                    "dunk",
+                                    "trainer",
+                                    "runner",
+                                    "retro",
+                                ]
+                                if not any(keyword in title_lower for keyword in keywords):
+                                    continue
+                            uid = utils.make_id(src["key"], link)
+                            if uid in state.state["pending"] or link in state.state["sent_links"]:
+                                continue
+                            pub_date = utils.parse_date_from_rss(item)
+                            images = []
+                            description = ""
+                            desc_elem = item.find("description")
+                            if desc_elem:
+                                desc_text = desc_elem.get_text()
+                                desc_soup = BeautifulSoup(desc_text, "html.parser")
+                                description = desc_soup.get_text(strip=True)[:500]
+                                first_img = desc_soup.find("img", src=True)
+                                if first_img:
+                                    img_url = first_img.get("src")
+                                    if img_url:
+                                        if not img_url.startswith("http"):
+                                            base_url = f"https://{urlparse(link).netloc}"
+                                            img_url = urljoin(base_url, img_url)
+                                        if utils.is_valid_image_url(img_url):
+                                            images.append(img_url)
+                            releases.append(
+                                {
+                                    "id": uid,
+                                    "title": title[:200],
+                                    "link": link,
+                                    "images": images,
+                                    "original_images": images.copy(),
+                                    "context": description,
+                                    "source": src["name"],
+                                    "category": src.get("category", "sneakers"),
+                                    "timestamp": pub_date.isoformat(),
+                                    "needs_parsing": True,
+                                    "tags": utils.extract_tags(title, description),
+                                }
+                            )
+                        except Exception:
+                            continue
+                except Exception:
+                    continue
+        except httpx.TimeoutException:
+            logging.error(f"Timeout –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ {src['name']}")
+        except httpx.RequestError as e:
+            logging.error(f"–û—à–∏–±–∫–∞ HTTP –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ {src['name']}: {e}")
+        except Exception as e:
+            logging.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ {src['name']}: {e}")
+    releases.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
+    logging.info(f"–ù–∞–π–¥–µ–Ω–æ {len(releases)} –Ω–æ–≤—ã—Ö —Ä–µ–ª–∏–∑–æ–≤ –≤—Å–µ–≥–æ")
+    return releases
+
diff --git a/hypebot/openai_utils.py b/hypebot/openai_utils.py
new file mode 100644
index 0000000000000000000000000000000000000000..b14a01e300e2d9d341d00c231de95a287599dd36
--- /dev/null
+++ b/hypebot/openai_utils.py
@@ -0,0 +1,58 @@
+import logging
+import base64
+import httpx
+from io import BytesIO
+from PIL import Image
+from openai import AsyncOpenAI
+from . import config
+
+openai_client = AsyncOpenAI(api_key=config.OPENAI_API_KEY)
+
+async def generate_image(prompt: str, style: str = "photographic") -> str | None:
+    try:
+        logging.info(f"–ì–µ–Ω–µ—Ä–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {prompt[:50]}...")
+        response = await openai_client.images.generate(
+            model="dall-e-3",
+            prompt=prompt,
+            size="1024x1024",
+            quality="standard",
+            n=1,
+        )
+        return response.data[0].url
+    except Exception as e:
+        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
+        return None
+
+async def download_image(url: str) -> bytes | None:
+    try:
+        async with httpx.AsyncClient() as client:
+            resp = await client.get(url, timeout=30)
+            resp.raise_for_status()
+            return resp.content
+    except Exception as e:
+        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
+        return None
+
+async def analyze_image(image_bytes: bytes) -> str:
+    try:
+        b64 = base64.b64encode(image_bytes).decode("utf-8")
+        response = await openai_client.chat.completions.create(
+            model="gpt-4-vision-preview",
+            messages=[
+                {
+                    "role": "user",
+                    "content": [
+                        {
+                            "type": "text",
+                            "text": "–û–ø–∏—à–∏ —á—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–æ –Ω–∞ —ç—Ç–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–µ"
+                        },
+                        {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{b64}"}}
+                    ],
+                }
+            ],
+            max_tokens=300,
+        )
+        return response.choices[0].message.content.strip()
+    except Exception as e:
+        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
+        return ""
diff --git a/hypebot/state.py b/hypebot/state.py
new file mode 100644
index 0000000000000000000000000000000000000000..e4fe2e1dc56757cf3202ba97c24575c30c0c8743
--- /dev/null
+++ b/hypebot/state.py
@@ -0,0 +1,124 @@
+import json
+import logging
+from datetime import datetime, timezone
+from typing import Dict, List
+import pytz
+from . import config
+
+state = {}
+
+
+def get_user_timezone():
+    return pytz.timezone(state.get("timezone", config.DEFAULT_TIMEZONE))
+
+
+def localize_datetime(dt: datetime) -> datetime:
+    if dt.tzinfo is None:
+        dt = dt.replace(tzinfo=timezone.utc)
+    user_tz = get_user_timezone()
+    return dt.astimezone(user_tz)
+
+
+def format_local_time(dt: datetime) -> str:
+    local_dt = localize_datetime(dt)
+    return local_dt.strftime("%d.%m.%Y %H:%M")
+
+
+def clean_old_posts(state_dict):
+    now = datetime.now(timezone.utc)
+    removed_count = 0
+    for uid in list(state_dict["pending"].keys()):
+        post = state_dict["pending"][uid]
+        try:
+            post_date = datetime.fromisoformat(post.get("timestamp", "").replace('Z', '+00:00'))
+            age = now - post_date
+            if age.days > config.MAX_POST_AGE_DAYS:
+                del state_dict["pending"][uid]
+                removed_count += 1
+        except Exception:
+            continue
+
+    if len(state_dict["pending"]) > config.MAX_PENDING_POSTS:
+        sorted_posts = sorted(
+            state_dict["pending"].items(),
+            key=lambda x: x[1].get("timestamp", ""),
+            reverse=True,
+        )
+        state_dict["pending"] = dict(sorted_posts[: config.MAX_PENDING_POSTS])
+        removed_count += len(sorted_posts) - config.MAX_PENDING_POSTS
+
+    if removed_count > 0:
+        logging.info(f"–£–¥–∞–ª–µ–Ω–æ {removed_count} —Å—Ç–∞—Ä—ã—Ö –ø–æ—Å—Ç–æ–≤")
+
+    return removed_count
+
+
+def load_state():
+    try:
+        with open(config.STATE_FILE, "r", encoding="utf-8") as f:
+            loaded = json.load(f)
+            defaults = {
+                "sent_links": [],
+                "pending": {},
+                "moderation_queue": [],
+                "preview_mode": {},
+                "thoughts_mode": False,
+                "scheduled_posts": {},
+                "generated_images": {},
+                "waiting_for_image": None,
+                "current_thought": None,
+                "waiting_for_schedule": None,
+                "editing_schedule": None,
+                "favorites": [],
+                "auto_publish": False,
+                "publish_interval": 3600,
+                "timezone": config.DEFAULT_TIMEZONE,
+                "channel": config.TELEGRAM_CHANNEL,
+                "waiting_for_channel": False,
+            }
+            for key, default in defaults.items():
+                if key not in loaded:
+                    loaded[key] = default
+
+            valid_pending = {}
+            for uid, record in loaded["pending"].items():
+                if isinstance(record, dict) and all(k in record for k in ["id", "title", "link"]):
+                    valid_pending[uid] = record
+                else:
+                    logging.warning(f"–£–¥–∞–ª—è—é –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é –∑–∞–ø–∏—Å—å –∏–∑ pending: {uid}")
+            loaded["pending"] = valid_pending
+            clean_old_posts(loaded)
+            return loaded
+    except (FileNotFoundError, json.JSONDecodeError) as e:
+        logging.info(f"–°–æ–∑–¥–∞—é –Ω–æ–≤—ã–π —Ñ–∞–π–ª —Å–æ—Å—Ç–æ—è–Ω–∏—è: {e}")
+        return {
+            "sent_links": [],
+            "pending": {},
+            "moderation_queue": [],
+            "preview_mode": {},
+            "thoughts_mode": False,
+            "scheduled_posts": {},
+            "generated_images": {},
+            "waiting_for_image": None,
+            "current_thought": None,
+            "waiting_for_schedule": None,
+            "editing_schedule": None,
+            "favorites": [],
+            "auto_publish": False,
+            "publish_interval": 3600,
+            "timezone": config.DEFAULT_TIMEZONE,
+            "channel": config.TELEGRAM_CHANNEL,
+            "waiting_for_channel": False,
+        }
+
+
+state = load_state()
+
+
+def save_state():
+    try:
+        with open(config.STATE_FILE, "w", encoding="utf-8") as f:
+            json.dump(state, f, ensure_ascii=False, indent=2)
+    except Exception as e:
+        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è: {e}")
+
diff --git a/hypebot/utils.py b/hypebot/utils.py
new file mode 100644
index 0000000000000000000000000000000000000000..89ad424734dcb47b32d8c1f93f29c6930091a2b8
--- /dev/null
+++ b/hypebot/utils.py
@@ -0,0 +1,205 @@
+import hashlib
+import httpx
+import logging
+import re
+from urllib.parse import urlparse, urljoin
+from datetime import datetime, timezone, timedelta
+from typing import Dict, List, Optional
+from bs4 import BeautifulSoup, FeatureNotFound
+
+from . import config
+from . import state
+
+
+def make_id(source: str, link: str) -> str:
+    return hashlib.md5(f"{source}|{link}".encode()).hexdigest()[:12]
+
+
+def is_valid_image_url(url: str) -> bool:
+    if not url or not isinstance(url, str):
+        return False
+    parsed = urlparse(url)
+    if not parsed.scheme or not parsed.netloc:
+        return False
+    valid_extensions = (".jpg", ".jpeg", ".png", ".gif", ".webp")
+    return any(parsed.path.lower().endswith(ext) for ext in valid_extensions)
+
+
+async def validate_image_url(client: httpx.AsyncClient, url: str) -> bool:
+    try:
+        resp = await client.head(url, timeout=10, follow_redirects=True)
+        ctype = resp.headers.get("content-type", "")
+        return resp.status_code == 200 and ctype.startswith("image/")
+    except Exception as e:
+        logging.debug(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è {url}: {e}")
+        return False
+
+
+def extract_tags(title: str, context: str = "") -> Dict[str, List[str]]:
+    tags = {"brands": [], "models": [], "types": [], "colors": []}
+    text = f"{title} {context}".lower()
+    for brand, keywords in config.BRAND_KEYWORDS.items():
+        for keyword in keywords:
+            if keyword in text:
+                if brand not in tags["brands"]:
+                    tags["brands"].append(brand)
+                break
+    for model, keywords in config.MODEL_KEYWORDS.items():
+        for keyword in keywords:
+            if keyword in text:
+                if model not in tags["models"]:
+                    tags["models"].append(model)
+                break
+    for release_type, keywords in config.RELEASE_TYPES.items():
+        for keyword in keywords:
+            if keyword in text:
+                if release_type not in tags["types"]:
+                    tags["types"].append(release_type)
+                break
+    colors = [
+        "black",
+        "white",
+        "red",
+        "blue",
+        "green",
+        "yellow",
+        "purple",
+        "pink",
+        "orange",
+        "grey",
+        "gray",
+        "—á–µ—Ä–Ω—ã–π",
+        "–±–µ–ª—ã–π",
+        "–∫—Ä–∞—Å–Ω—ã–π",
+        "—Å–∏–Ω–∏–π",
+        "–∑–µ–ª–µ–Ω—ã–π",
+        "–∂–µ–ª—Ç—ã–π",
+        "—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π",
+        "—Ä–æ–∑–æ–≤—ã–π",
+        "–æ—Ä–∞–Ω–∂–µ–≤—ã–π",
+        "—Å–µ—Ä—ã–π",
+    ]
+    for color in colors:
+        if color in text:
+            color_en = color if color in [
+                "black",
+                "white",
+                "red",
+                "blue",
+                "green",
+                "yellow",
+                "purple",
+                "pink",
+                "orange",
+                "grey",
+                "gray",
+            ] else None
+            if color_en and color_en not in tags["colors"]:
+                tags["colors"].append(color_en)
+    return tags
+
+
+def format_tags_for_display(tags: Dict[str, List[str]]) -> str:
+    result = []
+    if tags.get("brands"):
+        result.append(f"üè∑ –ë—Ä–µ–Ω–¥: {', '.join(tags['brands'])}")
+    if tags.get("models"):
+        result.append(f"üëü –ú–æ–¥–µ–ª—å: {', '.join(tags['models'])}")
+    if tags.get("types"):
+        result.append(f"üìå –¢–∏–ø: {', '.join(tags['types'])}")
+    if tags.get("colors"):
+        result.append(f"üé® –¶–≤–µ—Ç: {', '.join(tags['colors'])}")
+    return "\n".join(result) if result else ""
+
+
+def get_hashtags(title: str, category: str) -> str:
+    title_lower = title.lower()
+    if category == "sneakers":
+        for brand, tags in config.HASHTAGS["sneakers"].items():
+            if brand != "default" and (
+                brand in title_lower or (brand == "jordan" and "air jordan" in title_lower)
+            ):
+                return tags
+        return config.HASHTAGS["sneakers"]["default"]
+    else:
+        for brand, tags in config.HASHTAGS["fashion"].items():
+            if brand != "default" and (
+                brand in title_lower or (brand == "offwhite" and "off-white" in title_lower)
+            ):
+                return tags
+        return config.HASHTAGS["fashion"]["default"]
+
+
+def format_date_for_display(date_str: str) -> str:
+    try:
+        if isinstance(date_str, str):
+            date = datetime.fromisoformat(date_str.replace("Z", "+00:00"))
+        else:
+            date = date_str
+        local_date = state.localize_datetime(date)
+        now = state.localize_datetime(datetime.now(timezone.utc))
+        diff = now - local_date
+        if diff.days == 0:
+            return "–°–µ–≥–æ–¥–Ω—è"
+        elif diff.days == 1:
+            return "–í—á–µ—Ä–∞"
+        elif diff.days < 7:
+            return f"{diff.days} –¥–Ω–µ–π –Ω–∞–∑–∞–¥"
+        else:
+            return local_date.strftime("%d.%m.%Y")
+    except Exception:
+        return "–ù–µ–¥–∞–≤–Ω–æ"
+
+
+def parse_date_from_rss(item) -> datetime:
+    try:
+        date_elem = item.find("pubDate") or item.find("published") or item.find("dc:date")
+        if date_elem:
+            date_str = date_elem.get_text(strip=True)
+            from email.utils import parsedate_to_datetime
+            return parsedate_to_datetime(date_str)
+    except Exception:
+        pass
+    return datetime.now(timezone.utc)
+
+
+def parse_schedule_time(text: str) -> Optional[datetime]:
+    try:
+        text = text.strip()
+        user_tz = state.get_user_timezone()
+        now = datetime.now(user_tz)
+        time_match = re.match(r"^(\d{1,2}):(\d{2})$", text)
+        if time_match:
+            hours = int(time_match.group(1))
+            minutes = int(time_match.group(2))
+            if 0 <= hours <= 23 and 0 <= minutes <= 59:
+                scheduled = now.replace(hour=hours, minute=minutes, second=0, microsecond=0)
+                if scheduled <= now:
+                    scheduled += timedelta(days=1)
+                return scheduled.astimezone(timezone.utc)
+        datetime_match = re.match(r"^(\d{1,2})\.(\d{1,2})\s+(\d{1,2}):(\d{2})$", text)
+        if datetime_match:
+            day = int(datetime_match.group(1))
+            month = int(datetime_match.group(2))
+            hours = int(datetime_match.group(3))
+            minutes = int(datetime_match.group(4))
+            year = now.year
+            if 1 <= day <= 31 and 1 <= month <= 12 and 0 <= hours <= 23 and 0 <= minutes <= 59:
+                scheduled = user_tz.localize(datetime(year, month, day, hours, minutes))
+                if scheduled < now:
+                    scheduled = scheduled.replace(year=year + 1)
+                return scheduled.astimezone(timezone.utc)
+        relative_match = re.match(r"^(\+\d+)([hmd])$", text.lower())
+        if relative_match:
+            amount = int(relative_match.group(1)[1:])
+            unit = relative_match.group(2)
+            utc_now = datetime.now(timezone.utc)
+            if unit == "h" and 1 <= amount <= 24:
+                return utc_now + timedelta(hours=amount)
+            elif unit == "m" and 1 <= amount <= 1440:
+                return utc_now + timedelta(minutes=amount)
+            elif unit == "d" and 1 <= amount <= 30:
+                return utc_now + timedelta(days=amount)
+    except Exception as e:
+        logging.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –≤—Ä–µ–º–µ–Ω–∏: {e}")
+    return None
diff --git a/main.py b/main.py
new file mode 100644
index 0000000000000000000000000000000000000000..f1fa2028d79092120853996ca11ed233103553dd
--- /dev/null
+++ b/main.py
@@ -0,0 +1,5 @@
+from hypebot import config
+import monolith
+
+if __name__ == "__main__":
+    monolith.main()
diff --git "a/\320\242\320\265\320\272\321\201\321\202\320\276\320\262\321\213\320\271 \320\264\320\276\320\272\321\203\320\274\320\265\320\275\321\202.py" b/monolith.py
similarity index 65%
rename from "\320\242\320\265\320\272\321\201\321\202\320\276\320\262\321\213\320\271 \320\264\320\276\320\272\321\203\320\274\320\265\320\275\321\202.py"
rename to monolith.py
index 46655ed73cdbbd43c519336c147baabf96eec207..31acccd43acd913eead476ba9eb7ef40bdee458a 100644
--- "a/\320\242\320\265\320\272\321\201\321\202\320\276\320\262\321\213\320\271 \320\264\320\276\320\272\321\203\320\274\320\265\320\275\321\202.py"	
+++ b/monolith.py
@@ -1,1022 +1,115 @@
 #!/usr/bin/env python3
 # hypebot.py ‚Äî —É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–æ–Ω –∏ –Ω–æ–≤—ã–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏
 
-import os
-import json
-import logging
-import hashlib
-import asyncio
-import warnings
-import httpx
-import base64
-from io import BytesIO
-from PIL import Image
-from openai import AsyncOpenAI
+import httpx
 from bs4 import BeautifulSoup, FeatureNotFound, XMLParsedAsHTMLWarning
 from telegram import InputMediaPhoto, InlineKeyboardButton, InlineKeyboardMarkup, Update, PhotoSize
 from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
 from telegram.constants import ParseMode
 from telegram.error import TelegramError, Conflict, BadRequest
 from urllib.parse import urljoin, urlparse
 from datetime import datetime, timezone, timedelta
 from typing import Dict, List, Optional, Tuple
+from hypebot import config, state, utils, fetcher
+from hypebot.openai_utils import generate_image, download_image, analyze_image
 import re
 import pytz
 
 warnings.filterwarnings("ignore", category=XMLParsedAsHTMLWarning)
 
 logging.basicConfig(
     level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
 )
 logging.getLogger("httpx").setLevel(logging.WARNING)
 
-# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---
-TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN") or "–¢–í–û–ô_–¢–ï–õ–ï–ì–†–ê–ú_–¢–û–ö–ï–ù"
-TELEGRAM_CHANNEL = os.getenv("TELEGRAM_CHAT_ID") or "@channelusername"
-ADMIN_CHAT_ID = os.getenv("ADMIN_CHAT_ID") or "123456789"
-OPENAI_API_KEY = os.getenv("OPENAI_API_KEY") or "sk-...."
-STATE_FILE = "state.json"
-CHECK_INTERVAL_SECONDS = 1800
-MAX_PENDING_POSTS = 100
-MAX_POST_AGE_DAYS = 7
-MAX_IMAGES_PER_POST = 10  # –ú–∞–∫—Å–∏–º—É–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –ø–æ—Å—Ç–µ
 
-# –í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–æ–Ω–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ú–æ—Å–∫–≤–∞)
-DEFAULT_TIMEZONE = "Europe/Moscow"
-
-# –°—Ç–∏–ª–∏ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
-IMAGE_STYLES = {
-    "sneakers": {
-        "prompt_template": "Modern minimalist sneaker promotional image, {title}, clean background, professional product photography, studio lighting, high quality, 4k",
-        "style": "photographic"
-    },
-    "fashion": {
-        "prompt_template": "Fashion editorial style image, {title}, trendy streetwear aesthetic, urban background, magazine quality",
-        "style": "editorial"
-    },
-    "thoughts": {
-        "prompt_template": "Artistic abstract representation of {topic}, modern digital art, vibrant colors, emotional expression, Instagram story format",
-        "style": "artistic"
-    },
-    "custom": {
-        "prompt_template": "{custom_prompt}",
-        "style": "creative"
-    }
-}
-
-# –•—ç—à—Ç–µ–≥–∏ –¥–ª—è –ø–æ—Å—Ç–æ–≤
-HASHTAGS = {
-    "sneakers": {
-        "nike": "#nike #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–Ω–∞–π–∫ #–Ω–∏–∫–µ–±—É—Ç–∏–∫",
-        "adidas": "#adidas #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–∞–¥–∏–¥–∞—Å #threestripes", 
-        "jordan": "#jordan #airjordan #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–¥–∂–æ—Ä–¥–∞–Ω #jumpman",
-        "newbalance": "#newbalance #nb #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–Ω—å—é–±–∞–ª–∞–Ω—Å #madeinusa",
-        "puma": "#puma #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–ø—É–º–∞ #pumafamily",
-        "yeezy": "#yeezy #adidas #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–∏–∑–∏ #kanye",
-        "asics": "#asics #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–∞—Å–∏–∫—Å #geltechnology",
-        "reebok": "#reebok #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #—Ä–∏–±–æ–∫ #classic",
-        "vans": "#vans #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–≤–∞–Ω—Å #offthewall",
-        "converse": "#converse #sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #–∫–æ–Ω–≤–µ—Ä—Å #allstar",
-        "default": "#sneakers #–∫—Ä–æ—Å—Å–æ–≤–∫–∏ #streetwear #–æ–±—É–≤—å #sneakerhead"
-    },
-    "fashion": {
-        "supreme": "#supreme #streetwear #fashion #—Å—É–ø—Ä–∏–º #hypebeast",
-        "offwhite": "#offwhite #fashion #streetwear #virgilabloh",
-        "stussy": "#stussy #streetwear #fashion #stussytribe",
-        "palace": "#palace #streetwear #fashion #palaceskateboards",
-        "default": "#fashion #–º–æ–¥–∞ #streetwear #style #—Å—Ç–∏–ª—å #outfit"
-    }
-}
-
-# –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
-SOURCES = [
-    {
-        "key": "sneakernews", 
-        "name": "SneakerNews", 
-        "type": "json", 
-        "api": "https://sneakernews.com/wp-json/wp/v2/posts?per_page=10&_embed",
-        "category": "sneakers"
-    },
-    {
-        "key": "hypebeast", 
-        "name": "Hypebeast Footwear", 
-        "type": "rss", 
-        "api": "https://hypebeast.com/footwear/feed",
-        "category": "sneakers"
-    },
-    {
-        "key": "highsnobiety", 
-        "name": "Highsnobiety Sneakers", 
-        "type": "rss", 
-        "api": "https://www.highsnobiety.com/tag/sneakers/feed/",
-        "category": "sneakers"
-    },
-    {
-        "key": "hypebeast_fashion", 
-        "name": "Hypebeast Fashion", 
-        "type": "rss", 
-        "api": "https://hypebeast.com/fashion/feed",
-        "category": "fashion"
-    },
-    {
-        "key": "highsnobiety_fashion", 
-        "name": "Highsnobiety Fashion", 
-        "type": "rss", 
-        "api": "https://www.highsnobiety.com/tag/fashion/feed/",
-        "category": "fashion"
-    }
-]
-
-# –°–∏—Å—Ç–µ–º–∞ —Ç–µ–≥–æ–≤ –∏ –±—Ä–µ–Ω–¥–æ–≤
-BRAND_KEYWORDS = {
-    "nike": ["nike", "air max", "air force", "dunk", "blazer", "cortez", "vapormax", "pegasus"],
-    "adidas": ["adidas", "yeezy", "boost", "ultraboost", "nmd", "gazelle", "samba", "campus"],
-    "jordan": ["jordan", "air jordan", "aj1", "aj4", "aj11", "jumpman"],
-    "newbalance": ["new balance", "nb", "990", "991", "992", "993", "2002r", "550"],
-    "asics": ["asics", "gel", "gel-lyte", "gel-kayano", "gel-1090"],
-    "puma": ["puma", "suede", "clyde", "rs-x"],
-    "reebok": ["reebok", "classic", "club c", "question"],
-    "vans": ["vans", "old skool", "sk8-hi", "authentic", "era"],
-    "converse": ["converse", "chuck taylor", "all star", "one star"],
-    "salomon": ["salomon", "xt-6", "speedcross"],
-    "supreme": ["supreme", "box logo"],
-    "offwhite": ["off-white", "off white", "virgil abloh"],
-    "stussy": ["stussy", "st√ºssy"],
-    "palace": ["palace", "palace skateboards"]
-}
-
-# –ú–æ–¥–µ–ª–∏ –∫—Ä–æ—Å—Å–æ–≤–æ–∫
-MODEL_KEYWORDS = {
-    "airmax": ["air max", "airmax", "am1", "am90", "am95", "am97"],
-    "airforce": ["air force", "af1", "air force 1"],
-    "dunk": ["dunk", "dunk low", "dunk high", "sb dunk"],
-    "yeezy": ["yeezy", "boost 350", "boost 700", "foam runner"],
-    "jordan1": ["jordan 1", "aj1", "air jordan 1"],
-    "jordan4": ["jordan 4", "aj4", "air jordan 4"],
-    "ultraboost": ["ultraboost", "ultra boost"],
-    "990": ["990", "990v", "990v5", "990v6"]
-}
-
-# –¢–∏–ø—ã —Ä–µ–ª–∏–∑–æ–≤
-RELEASE_TYPES = {
-    "retro": ["retro", "og", "original", "vintage"],
-    "collab": ["collab", "collaboration", "x ", " x ", "partner"],
-    "limited": ["limited", "exclusive", "rare", "special edition"],
-    "womens": ["women", "wmns", "female"],
-    "kids": ["kids", "gs", "gradeschool", "youth"],
-    "lifestyle": ["lifestyle", "casual", "street"],
-    "performance": ["performance", "running", "basketball", "training"]
-}
-
-# --- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ ---
-if not all([TELEGRAM_TOKEN, OPENAI_API_KEY]):
-    logging.critical("–ù–µ –∑–∞–¥–∞–Ω—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è")
-    exit(1)
-
-# –ü—Ä–æ–≤–µ—Ä—è–µ–º ADMIN_CHAT_ID
-if ADMIN_CHAT_ID and ADMIN_CHAT_ID != "123456789":
-    try:
-        ADMIN_CHAT_ID = int(ADMIN_CHAT_ID)
-    except ValueError:
-        logging.critical("ADMIN_CHAT_ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º")
-        exit(1)
-else:
-    ADMIN_CHAT_ID = None
-
-# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è OpenAI –∫–ª–∏–µ–Ω—Ç–∞
-openai_client = AsyncOpenAI(api_key=OPENAI_API_KEY)
-
-def get_user_timezone():
-    """–ü–æ–ª—É—á–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—É—é –∑–æ–Ω—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
-    return pytz.timezone(state.get("timezone", DEFAULT_TIMEZONE))
-
-def localize_datetime(dt: datetime) -> datetime:
-    """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å UTC –≤—Ä–µ–º—è –≤ –ª–æ–∫–∞–ª—å–Ω–æ–µ"""
-    if dt.tzinfo is None:
-        dt = dt.replace(tzinfo=timezone.utc)
-    user_tz = get_user_timezone()
-    return dt.astimezone(user_tz)
-
-def format_local_time(dt: datetime) -> str:
-    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è –≤ –ª–æ–∫–∞–ª—å–Ω–æ–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∑–æ–Ω–µ"""
-    local_dt = localize_datetime(dt)
-    return local_dt.strftime("%d.%m.%Y %H:%M")
-
-def clean_old_posts(state_dict):
-    """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –ø–æ—Å—Ç–æ–≤ –∏–∑ –æ—á–µ—Ä–µ–¥–∏"""
-    now = datetime.now(timezone.utc)
-    removed_count = 0
-    
-    # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –ø–æ—Å—Ç—ã
-    for uid in list(state_dict["pending"].keys()):
-        post = state_dict["pending"][uid]
-        try:
-            post_date = datetime.fromisoformat(post.get("timestamp", "").replace('Z', '+00:00'))
-            age = now - post_date
-            
-            if age.days > MAX_POST_AGE_DAYS:
-                del state_dict["pending"][uid]
-                removed_count += 1
-        except:
-            continue
-    
-    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Å—Ç–æ–≤
-    if len(state_dict["pending"]) > MAX_PENDING_POSTS:
-        sorted_posts = sorted(
-            state_dict["pending"].items(),
-            key=lambda x: x[1].get("timestamp", ""),
-            reverse=True
-        )
-        
-        state_dict["pending"] = dict(sorted_posts[:MAX_PENDING_POSTS])
-        removed_count += len(sorted_posts) - MAX_PENDING_POSTS
-    
-    if removed_count > 0:
-        logging.info(f"–£–¥–∞–ª–µ–Ω–æ {removed_count} —Å—Ç–∞—Ä—ã—Ö –ø–æ—Å—Ç–æ–≤")
-    
-    return removed_count
-
-def load_state():
-    try:
-        with open(STATE_FILE, "r", encoding="utf-8") as f:
-            state = json.load(f)
-            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª–µ–π
-            defaults = {
-                "sent_links": [],
-                "pending": {},
-                "moderation_queue": [],
-                "preview_mode": {},
-                "thoughts_mode": False,
-                "scheduled_posts": {},
-                "generated_images": {},
-                "waiting_for_image": None,
-                "current_thought": None,
-                "waiting_for_schedule": None,
-                "editing_schedule": None,
-                "favorites": [],
-                "auto_publish": False,
-                "publish_interval": 3600,
-                "timezone": DEFAULT_TIMEZONE,
-                "channel": TELEGRAM_CHANNEL,
-                "waiting_for_channel": False
-            }
-            
-            for key, default_value in defaults.items():
-                if key not in state:
-                    state[key] = default_value
-            
-            # –í–∞–ª–∏–¥–∞—Ü–∏—è pending –∑–∞–ø–∏—Å–µ–π
-            valid_pending = {}
-            for uid, record in state["pending"].items():
-                if isinstance(record, dict) and all(key in record for key in ['id', 'title', 'link']):
-                    valid_pending[uid] = record
-                else:
-                    logging.warning(f"–£–¥–∞–ª—è—é –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é –∑–∞–ø–∏—Å—å –∏–∑ pending: {uid}")
-            state["pending"] = valid_pending
-            
-            # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –ø–æ—Å—Ç–æ–≤
-            clean_old_posts(state)
-            
-            return state
-    except (FileNotFoundError, json.JSONDecodeError) as e:
-        logging.info(f"–°–æ–∑–¥–∞—é –Ω–æ–≤—ã–π —Ñ–∞–π–ª —Å–æ—Å—Ç–æ—è–Ω–∏—è: {e}")
-        return {
-            "sent_links": [], 
-            "pending": {}, 
-            "moderation_queue": [], 
-            "preview_mode": {}, 
-            "thoughts_mode": False,
-            "scheduled_posts": {},
-            "generated_images": {},
-            "waiting_for_image": None,
-            "current_thought": None,
-            "waiting_for_schedule": None,
-            "editing_schedule": None,
-            "favorites": [],
-            "auto_publish": False,
-            "publish_interval": 3600,
-            "timezone": DEFAULT_TIMEZONE,
-            "channel": TELEGRAM_CHANNEL,
-            "waiting_for_channel": False
-        }
-
-state = load_state()
-
-def save_state():
-    try:
-        with open(STATE_FILE, "w", encoding="utf-8") as f:
-            json.dump(state, f, ensure_ascii=False, indent=2)
-    except Exception as e:
-        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è: {e}")
-
-def make_id(source: str, link: str) -> str:
-    return hashlib.md5(f"{source}|{link}".encode()).hexdigest()[:12]
-
-def is_valid_image_url(url: str) -> bool:
-    if not url or not isinstance(url, str):
-        return False
-    parsed = urlparse(url)
-    if not parsed.scheme or not parsed.netloc:
-        return False
-    valid_extensions = ('.jpg', '.jpeg', '.png', '.gif', '.webp')
-    return any(parsed.path.lower().endswith(ext) for ext in valid_extensions)
-
-async def validate_image_url(client: httpx.AsyncClient, url: str) -> bool:
-    try:
-        response = await client.head(url, timeout=10, follow_redirects=True)
-        content_type = response.headers.get('content-type', '')
-        return response.status_code == 200 and content_type.startswith('image/')
-    except Exception as e:
-        logging.debug(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è {url}: {e}")
-        return False
-
-def extract_tags(title: str, context: str = "") -> Dict[str, List[str]]:
-    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–≥–æ–≤ –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞"""
-    tags = {
-        "brands": [],
-        "models": [],
-        "types": [],
-        "colors": []
-    }
-    
-    text = f"{title} {context}".lower()
-    
-    # –ò–∑–≤–ª–µ–∫–∞–µ–º –±—Ä–µ–Ω–¥—ã
-    for brand, keywords in BRAND_KEYWORDS.items():
-        for keyword in keywords:
-            if keyword in text:
-                if brand not in tags["brands"]:
-                    tags["brands"].append(brand)
-                break
-    
-    # –ò–∑–≤–ª–µ–∫–∞–µ–º –º–æ–¥–µ–ª–∏
-    for model, keywords in MODEL_KEYWORDS.items():
-        for keyword in keywords:
-            if keyword in text:
-                if model not in tags["models"]:
-                    tags["models"].append(model)
-                break
-    
-    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–∏–ø—ã —Ä–µ–ª–∏–∑–æ–≤
-    for release_type, keywords in RELEASE_TYPES.items():
-        for keyword in keywords:
-            if keyword in text:
-                if release_type not in tags["types"]:
-                    tags["types"].append(release_type)
-                break
-    
-    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ü–≤–µ—Ç–∞
-    colors = ["black", "white", "red", "blue", "green", "yellow", "purple", "pink", "orange", "grey", "gray", 
-              "—á–µ—Ä–Ω—ã–π", "–±–µ–ª—ã–π", "–∫—Ä–∞—Å–Ω—ã–π", "—Å–∏–Ω–∏–π", "–∑–µ–ª–µ–Ω—ã–π", "–∂–µ–ª—Ç—ã–π", "—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π", "—Ä–æ–∑–æ–≤—ã–π", "–æ—Ä–∞–Ω–∂–µ–≤—ã–π", "—Å–µ—Ä—ã–π"]
-    for color in colors:
-        if color in text:
-            color_en = color if color in ["black", "white", "red", "blue", "green", "yellow", "purple", "pink", "orange", "grey", "gray"] else None
-            if color_en and color_en not in tags["colors"]:
-                tags["colors"].append(color_en)
-    
-    return tags
-
-def format_tags_for_display(tags: Dict[str, List[str]]) -> str:
-    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–≥–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
-    result = []
-    
-    if tags.get("brands"):
-        result.append(f"üè∑ –ë—Ä–µ–Ω–¥: {', '.join(tags['brands'])}")
-    if tags.get("models"):
-        result.append(f"üëü –ú–æ–¥–µ–ª—å: {', '.join(tags['models'])}")
-    if tags.get("types"):
-        result.append(f"üìå –¢–∏–ø: {', '.join(tags['types'])}")
-    if tags.get("colors"):
-        result.append(f"üé® –¶–≤–µ—Ç: {', '.join(tags['colors'])}")
-    
-    return "\n".join(result) if result else ""
-
-def get_hashtags(title: str, category: str) -> str:
-    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö—ç—à—Ç–µ–≥–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑–∞–≥–æ–ª–æ–≤–∫–∞ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"""
-    title_lower = title.lower()
-    
-    if category == "sneakers":
-        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±—Ä–µ–Ω–¥—ã
-        for brand, tags in HASHTAGS["sneakers"].items():
-            if brand != "default":
-                if brand in title_lower or (brand == "jordan" and "air jordan" in title_lower):
-                    return tags
-        return HASHTAGS["sneakers"]["default"]
-    else:
-        # –î–ª—è –º–æ–¥—ã
-        for brand, tags in HASHTAGS["fashion"].items():
-            if brand != "default":
-                if brand in title_lower or (brand == "offwhite" and "off-white" in title_lower):
-                    return tags
-        return HASHTAGS["fashion"]["default"]
-
-def format_date_for_display(date_str: str) -> str:
-    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
-    try:
-        if isinstance(date_str, str):
-            date = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
-        else:
-            date = date_str
-        
-        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –ª–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
-        local_date = localize_datetime(date)
-        now = localize_datetime(datetime.now(timezone.utc))
-        diff = now - local_date
-        
-        if diff.days == 0:
-            return "–°–µ–≥–æ–¥–Ω—è"
-        elif diff.days == 1:
-            return "–í—á–µ—Ä–∞"
-        elif diff.days < 7:
-            return f"{diff.days} –¥–Ω–µ–π –Ω–∞–∑–∞–¥"
-        else:
-            return local_date.strftime("%d.%m.%Y")
-    except:
-        return "–ù–µ–¥–∞–≤–Ω–æ"
-
-def parse_date_from_rss(item) -> datetime:
-    """–ü–∞—Ä—Å–∏–Ω–≥ –¥–∞—Ç—ã –∏–∑ RSS —ç–ª–µ–º–µ–Ω—Ç–∞"""
-    try:
-        date_elem = item.find("pubDate") or item.find("published") or item.find("dc:date")
-        if date_elem:
-            date_str = date_elem.get_text(strip=True)
-            from email.utils import parsedate_to_datetime
-            return parsedate_to_datetime(date_str)
-    except:
-        pass
-    return datetime.now(timezone.utc)
-
-def parse_schedule_time(text: str) -> Optional[datetime]:
-    """–ü–∞—Ä—Å–∏–Ω–≥ –≤—Ä–µ–º–µ–Ω–∏/–¥–∞—Ç—ã –∏–∑ —Ç–µ–∫—Å—Ç–∞ —Å —É—á–µ—Ç–æ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∑–æ–Ω—ã"""
-    try:
-        text = text.strip()
-        user_tz = get_user_timezone()
-        now = datetime.now(user_tz)
-        
-        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
-        # 1. –¢–æ–ª—å–∫–æ –≤—Ä–µ–º—è –ß–ß:–ú–ú
-        time_match = re.match(r'^(\d{1,2}):(\d{2})$', text)
-        if time_match:
-            hours = int(time_match.group(1))
-            minutes = int(time_match.group(2))
-            if 0 <= hours <= 23 and 0 <= minutes <= 59:
-                scheduled = now.replace(hour=hours, minute=minutes, second=0, microsecond=0)
-                if scheduled <= now:
-                    scheduled += timedelta(days=1)
-                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ UTC –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è
-                return scheduled.astimezone(timezone.utc)
-        
-        # 2. –î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è –î–î.–ú–ú –ß–ß:–ú–ú
-        datetime_match = re.match(r'^(\d{1,2})\.(\d{1,2})\s+(\d{1,2}):(\d{2})$', text)
-        if datetime_match:
-            day = int(datetime_match.group(1))
-            month = int(datetime_match.group(2))
-            hours = int(datetime_match.group(3))
-            minutes = int(datetime_match.group(4))
-            year = now.year
-            
-            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å
-            if 1 <= day <= 31 and 1 <= month <= 12 and 0 <= hours <= 23 and 0 <= minutes <= 59:
-                scheduled = user_tz.localize(datetime(year, month, day, hours, minutes))
-                # –ï—Å–ª–∏ –¥–∞—Ç–∞ –≤ –ø—Ä–æ—à–ª–æ–º, –±–µ—Ä–µ–º —Å–ª–µ–¥—É—é—â–∏–π –≥–æ–¥
-                if scheduled < now:
-                    scheduled = scheduled.replace(year=year + 1)
-                return scheduled.astimezone(timezone.utc)
-        
-        # 3. –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è +1h, +30m, +2d
-        relative_match = re.match(r'^\+(\d+)([hmd])$', text.lower())
-        if relative_match:
-            amount = int(relative_match.group(1))
-            unit = relative_match.group(2)
-            
-            utc_now = datetime.now(timezone.utc)
-            if unit == 'h' and 1 <= amount <= 24:
-                return utc_now + timedelta(hours=amount)
-            elif unit == 'm' and 1 <= amount <= 1440:
-                return utc_now + timedelta(minutes=amount)
-            elif unit == 'd' and 1 <= amount <= 30:
-                return utc_now + timedelta(days=amount)
-        
-    except Exception as e:
-        logging.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –≤—Ä–µ–º–µ–Ω–∏: {e}")
-    
-    return None
-
-async def generate_image(prompt: str, style: str = "photographic") -> Optional[str]:
-    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —á–µ—Ä–µ–∑ DALL-E 3"""
-    try:
-        logging.info(f"–ì–µ–Ω–µ—Ä–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {prompt[:50]}...")
-        
-        response = await openai_client.images.generate(
-            model="dall-e-3",
-            prompt=prompt,
-            size="1024x1024",
-            quality="standard",
-            n=1,
-        )
-        
-        image_url = response.data[0].url
-        logging.info("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ —É—Å–ø–µ—à–Ω–æ")
-        return image_url
-        
-    except Exception as e:
-        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
-        return None
-
-async def download_image(url: str) -> Optional[bytes]:
-    """–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ URL"""
-    try:
-        async with httpx.AsyncClient() as client:
-            response = await client.get(url, timeout=30)
-            response.raise_for_status()
-            return response.content
-    except Exception as e:
-        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
-        return None
-
-async def analyze_image(image_bytes: bytes) -> str:
-    """–ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —á–µ—Ä–µ–∑ GPT-4 Vision"""
-    try:
-        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ base64
-        base64_image = base64.b64encode(image_bytes).decode('utf-8')
-        
-        response = await openai_client.chat.completions.create(
-            model="gpt-4-vision-preview",
-            messages=[
-                {
-                    "role": "user",
-                    "content": [
-                        {
-                            "type": "text",
-                            "text": "–û–ø–∏—à–∏ —á—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–æ –Ω–∞ —ç—Ç–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–µ. –û—Å–æ–±–æ–µ –≤–Ω–∏–º–∞–Ω–∏–µ —É–¥–µ–ª–∏ –¥–µ—Ç–∞–ª—è–º, —Ü–≤–µ—Ç–∞–º, —Å—Ç–∏–ª—é. –ï—Å–ª–∏ —ç—Ç–æ –∫—Ä–æ—Å—Å–æ–≤–∫–∏ –∏–ª–∏ –æ–¥–µ–∂–¥–∞ - –æ–ø–∏—à–∏ –º–æ–¥–µ–ª—å, –±—Ä–µ–Ω–¥, –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –¥–∏–∑–∞–π–Ω–∞."
-                        },
-                        {
-                            "type": "image_url",
-                            "image_url": {
-                                "url": f"data:image/jpeg;base64,{base64_image}"
-                            }
-                        }
-                    ]
-                }
-            ],
-            max_tokens=300
-        )
-        
-        return response.choices[0].message.content.strip()
-        
-    except Exception as e:
-        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
-        return ""
-
-async def extract_all_images_from_page(client: httpx.AsyncClient, url: str) -> List[str]:
-    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã"""
-    images = []
-    try:
-        headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"}
-        response = await client.get(url, headers=headers, timeout=20, follow_redirects=True)
-        
-        if response.status_code == 200:
-            soup = BeautifulSoup(response.text, "html.parser")
-            base_url = f"{urlparse(url).scheme}://{urlparse(url).netloc}"
-            
-            # –†–∞–∑–ª–∏—á–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
-            selectors = [
-                "div.gallery img",
-                "div.post-gallery img", 
-                "div.article-gallery img",
-                "div.gallery-container img",
-                "figure img",
-                "div.post-content img",
-                "article img",
-                "div[class*='gallery'] img",
-                "div[class*='slider'] img",
-                "div.entry-content img"
-            ]
-            
-            seen_urls = set()
-            
-            for selector in selectors:
-                for img in soup.select(selector):
-                    img_url = img.get("src") or img.get("data-src") or img.get("data-lazy-src")
-                    if not img_url:
-                        continue
-                    
-                    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ URL –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ
-                    if not img_url.startswith("http"):
-                        img_url = urljoin(base_url, img_url)
-                    
-                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –∏ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å
-                    if is_valid_image_url(img_url) and img_url not in seen_urls:
-                        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –º–∞–ª–µ–Ω—å–∫–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (–ª–æ–≥–æ—Ç–∏–ø—ã –∏ —Ç.–¥.)
-                        if "logo" not in img_url.lower() and "icon" not in img_url.lower():
-                            images.append(img_url)
-                            seen_urls.add(img_url)
-                    
-                    if len(images) >= MAX_IMAGES_PER_POST:
-                        break
-                
-                if len(images) >= MAX_IMAGES_PER_POST:
-                    break
-            
-            logging.info(f"–ù–∞–π–¥–µ–Ω–æ {len(images)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {url}")
-            
-    except Exception as e:
-        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {e}")
-    
-    return images[:MAX_IMAGES_PER_POST]
-
-async def parse_full_content(client: httpx.AsyncClient, record: dict) -> dict:
-    """–ü–æ–ª–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ—Å—Ç–∞"""
-    try:
-        # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
-        all_images = await extract_all_images_from_page(client, record["link"])
-        
-        if all_images:
-            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
-            record["images"] = all_images
-            record["original_images"] = all_images.copy()
-            logging.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–æ {len(all_images)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –ø–æ—Å—Ç–∞ {record['title'][:30]}...")
-        
-        record["needs_parsing"] = False
-        
-    except Exception as e:
-        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª–Ω–æ–º –ø–∞—Ä—Å–∏–Ω–≥–µ: {e}")
-    
-    return record
-
-async def fetch_releases(client: httpx.AsyncClient, progress_message=None, bot=None) -> list:
-    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"}
-    releases = []
-    seen_titles = set()
-    
-    total_sources = len(SOURCES)
-    
-    for idx, src in enumerate(SOURCES):
-        try:
-            # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
-            if progress_message and bot:
-                try:
-                    await bot.edit_message_text(
-                        f"üîÑ –ü—Ä–æ–≤–µ—Ä—è—é –∏—Å—Ç–æ—á–Ω–∏–∫–∏... ({idx + 1}/{total_sources})\n"
-                        f"üìç –°–µ–π—á–∞—Å: {src['name']}",
-                        progress_message.chat.id,
-                        progress_message.message_id
-                    )
-                except:
-                    pass
-            
-            logging.info(f"–ü—Ä–æ–≤–µ—Ä—è—é –∏—Å—Ç–æ—á–Ω–∏–∫: {src['name']}")
-            resp = await client.get(src["api"], headers=headers, timeout=20)
-            resp.raise_for_status()
-            
-            if src["type"] == "json":
-                try:
-                    posts = resp.json()
-                    if not isinstance(posts, list):
-                        logging.warning(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö –æ—Ç {src['name']}")
-                        continue
-                    logging.info(f"–ù–∞–π–¥–µ–Ω–æ {len(posts)} –ø–æ—Å—Ç–æ–≤ –æ—Ç {src['name']}")
-                except json.JSONDecodeError:
-                    logging.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –æ—Ç {src['name']}")
-                    continue
-                
-                for post in posts[:10]:
-                    try:
-                        link = post.get("link")
-                        title_data = post.get("title", {})
-                        title = title_data.get("rendered", "") if isinstance(title_data, dict) else str(title_data)
-                        title = BeautifulSoup(title, "html.parser").get_text(strip=True)
-                        
-                        if not link or not title or len(title) < 10:
-                            continue
-                        
-                        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã –ø–æ –∑–∞–≥–æ–ª–æ–≤–∫—É
-                        title_key = title.lower().strip()
-                        if title_key in seen_titles:
-                            logging.debug(f"–ü—Ä–æ–ø—É—Å–∫–∞—é –¥—É–±–ª–∏–∫–∞—Ç: {title}")
-                            continue
-                        seen_titles.add(title_key)
-                        
-                        uid = make_id(src["key"], link)
-                        if uid in state["pending"] or link in state["sent_links"]:
-                            continue
-                        
-                        # –ü–æ–ª—É—á–∞–µ–º –¥–∞—Ç—É
-                        date_str = post.get("date") or post.get("modified")
-                        if date_str:
-                            pub_date = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
-                        else:
-                            pub_date = datetime.now(timezone.utc)
-                        
-                        images = []
-                        # –ü–æ–ª—É—á–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ featuredmedia
-                        media = post.get("_embedded", {}).get("wp:featuredmedia", [])
-                        if media and isinstance(media, list) and len(media) > 0:
-                            featured_url = media[0].get("source_url")
-                            if featured_url and is_valid_image_url(featured_url):
-                                images.append(featured_url)
-                        
-                        context = ""
-                        
-                        releases.append({
-                            "id": uid,
-                            "title": title[:200],
-                            "link": link,
-                            "images": images,
-                            "original_images": images.copy(),
-                            "context": context[:500] if context else "",
-                            "source": src["name"],
-                            "category": src.get("category", "sneakers"),
-                            "timestamp": pub_date.isoformat(),
-                            "needs_parsing": True,  # –í—Å–µ–≥–¥–∞ –ø–∞—Ä—Å–∏–º –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
-                            "tags": extract_tags(title, context)  # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–≥–∏
-                        })
-                        logging.info(f"–î–æ–±–∞–≤–ª–µ–Ω —Ä–µ–ª–∏–∑: {title[:50]}... –æ—Ç {src['name']}")
-                    except Exception as e:
-                        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ø–æ—Å—Ç–∞ –æ—Ç {src['name']}: {e}")
-                        continue
-            
-            elif src["type"] == "rss":
-                try:
-                    # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã
-                    try:
-                        soup = BeautifulSoup(resp.text, "xml")
-                        items = soup.find_all("item")
-                    except FeatureNotFound:
-                        soup = BeautifulSoup(resp.text, "html.parser")
-                        items = soup.find_all("item")
-                    
-                    if not items:
-                        items = soup.find_all("entry")
-                    
-                    logging.info(f"–ù–∞–π–¥–µ–Ω–æ {len(items)} –∑–∞–ø–∏—Å–µ–π –≤ RSS –æ—Ç {src['name']}")
-                    
-                    for item in items[:10]:
-                        try:
-                            # –ü–æ–ª—É—á–∞–µ–º —Å—Å—ã–ª–∫—É
-                            link = None
-                            link_elem = item.find("link")
-                            if link_elem:
-                                link = link_elem.get_text(strip=True) if link_elem.string else link_elem.get("href")
-                            
-                            if not link:
-                                guid = item.find("guid")
-                                if guid and guid.get_text(strip=True).startswith("http"):
-                                    link = guid.get_text(strip=True)
-                            
-                            # –ü–æ–ª—É—á–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
-                            title = None
-                            title_elem = item.find("title")
-                            if title_elem:
-                                title = title_elem.get_text(strip=True)
-                            
-                            if not link or not title or len(title) < 10:
-                                continue
-                            
-                            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
-                            title_key = title.lower().strip()
-                            if title_key in seen_titles:
-                                logging.debug(f"–ü—Ä–æ–ø—É—Å–∫–∞—é –¥—É–±–ª–∏–∫–∞—Ç: {title}")
-                                continue
-                            seen_titles.add(title_key)
-                            
-                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é
-                            if src.get("category") == "sneakers":
-                                title_lower = title.lower()
-                                keywords = ['nike', 'adidas', 'jordan', 'yeezy', 'new balance', 'puma', 
-                                           'reebok', 'vans', 'converse', 'asics', 'sneaker', 'shoe', 
-                                           'footwear', 'release', 'drop', 'collab', 'air max', 'dunk',
-                                           'trainer', 'runner', 'retro']
-                                if not any(keyword in title_lower for keyword in keywords):
-                                    logging.debug(f"–ü—Ä–æ–ø—É—Å–∫–∞—é –Ω–µ-–∫—Ä–æ—Å—Å–æ–≤–æ—á–Ω—ã–π –ø–æ—Å—Ç: {title}")
-                                    continue
-                            
-                            uid = make_id(src["key"], link)
-                            if uid in state["pending"] or link in state["sent_links"]:
-                                continue
-                            
-                            # –ü–æ–ª—É—á–∞–µ–º –¥–∞—Ç—É
-                            pub_date = parse_date_from_rss(item)
-                            
-                            images = []
-                            description = ""
-                            
-                            # –ü–æ–ª—É—á–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
-                            desc_elem = item.find("description")
-                            if desc_elem:
-                                desc_text = desc_elem.get_text()
-                                desc_soup = BeautifulSoup(desc_text, "html.parser")
-                                description = desc_soup.get_text(strip=True)[:500]
-                                
-                                # –ò—â–µ–º –ø–µ—Ä–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø—Ä–µ–≤—å—é
-                                first_img = desc_soup.find("img", src=True)
-                                if first_img:
-                                    img_url = first_img.get("src")
-                                    if img_url:
-                                        if not img_url.startswith("http"):
-                                            base_url = f"https://{urlparse(link).netloc}"
-                                            img_url = urljoin(base_url, img_url)
-                                        if is_valid_image_url(img_url):
-                                            images.append(img_url)
-                            
-                            releases.append({
-                                "id": uid,
-                                "title": title[:200],
-                                "link": link,
-                                "images": images,
-                                "original_images": images.copy(),
-                                "context": description,
-                                "source": src["name"],
-                                "category": src.get("category", "sneakers"),
-                                "timestamp": pub_date.isoformat(),
-                                "needs_parsing": True,  # –í—Å–µ–≥–¥–∞ –ø–∞—Ä—Å–∏–º –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
-                                "tags": extract_tags(title, description)  # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–≥–∏
-                            })
-                            logging.info(f"–î–æ–±–∞–≤–ª–µ–Ω RSS —Ä–µ–ª–∏–∑: {title[:50]}... –æ—Ç {src['name']}")
-                        except Exception as e:
-                            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ RSS-—ç–ª–µ–º–µ–Ω—Ç–∞ –æ—Ç {src['name']}: {e}")
-                            continue
-                except Exception as e:
-                    logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ RSS –æ—Ç {src['name']}: {e}")
-                    continue
-        
-        except httpx.TimeoutException:
-            logging.error(f"Timeout –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ {src['name']}")
-        except httpx.RequestError as e:
-            logging.error(f"–û—à–∏–±–∫–∞ HTTP –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ {src['name']}: {e}")
-        except Exception as e:
-            logging.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ {src['name']}: {e}")
-    
-    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ (–Ω–æ–≤—ã–µ –ø–µ—Ä–≤—ã–º–∏)
-    releases.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
-    
-    logging.info(f"–ù–∞–π–¥–µ–Ω–æ {len(releases)} –Ω–æ–≤—ã—Ö —Ä–µ–ª–∏–∑–æ–≤ –≤—Å–µ–≥–æ")
-    return releases
-
-async def gen_caption(title: str, context: str, category: str = "sneakers", is_thought: bool = False, image_description: str = "") -> str:
-    if is_thought:
-        # –†–µ–∂–∏–º "–º—ã—Å–ª–µ–π" - –±–æ–ª–µ–µ —á–µ–ª–æ–≤–µ—á–Ω—ã–π –∏ –ª–∏—á–Ω—ã–π —Å—Ç–∏–ª—å
-        system_prompt = """–¢—ã –≤–µ–¥–µ—à—å –ª–∏—á–Ω—ã–π –±–ª–æ–≥ –æ –∫—Ä–æ—Å—Å–æ–≤–∫–∞—Ö –∏ —É–ª–∏—á–Ω–æ–π –º–æ–¥–µ. –ü–∏—à–∏ –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞, –∫–∞–∫ –±—É–¥—Ç–æ –¥–µ–ª–∏—à—å—Å—è —Å–≤–æ–∏–º–∏ –º—ã—Å–ª—è–º–∏ —Å –¥—Ä—É–∑—å—è–º–∏. –°—Ç–∏–ª—å –Ω–µ–ø—Ä–∏–Ω—É–∂–¥–µ–Ω–Ω—ã–π, —Å —ç–º–æ—Ü–∏—è–º–∏ –∏ –ª–∏—á–Ω—ã–º –æ—Ç–Ω–æ—à–µ–Ω–∏–µ–º. 
-
-–ü–†–ê–í–ò–õ–ê –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø –≠–ú–û–î–ó–ò:
-- –¢–û–õ–¨–ö–û –≤ –Ω–∞—á–∞–ª–µ –∞–±–∑–∞—Ü–∞ –∏–ª–∏ –≤—Å–µ–≥–æ –ø–æ—Å—Ç–∞
-- –ù–ï –ë–û–õ–ï–ï –æ–¥–Ω–æ–≥–æ —ç–º–æ–¥–∑–∏ –Ω–∞ –∞–±–∑–∞—Ü
-- –ù–ï –∏—Å–ø–æ–ª—å–∑—É–π —ç–º–æ–¥–∑–∏ –≤–Ω—É—Ç—Ä–∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π
-- –ü–æ–¥—Ö–æ–¥—è—â–∏–µ —ç–º–æ–¥–∑–∏: üòç üî• üí≠ ü§î üòé ‚ú® üëü
-
-–ú–æ–∂–µ—à—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:
-- –õ–∏—á–Ω—ã–µ –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏—è ("–º–Ω–µ –∫–∞–∂–µ—Ç—Å—è", "–ø–æ-–º–æ–µ–º—É", "—á–µ—Å—Ç–Ω–æ –≥–æ–≤–æ—Ä—è")
-- –≠–º–æ—Ü–∏–∏ ("–æ–±–∞–ª–¥–µ–ª –∫–æ–≥–¥–∞ —É–≤–∏–¥–µ–ª", "–≤–ª—é–±–∏–ª—Å—è —Å –ø–µ—Ä–≤–æ–≥–æ –≤–∑–≥–ª—è–¥–∞", "–Ω–µ –º–æ–≥—É –Ω–∞–ª—é–±–æ–≤–∞—Ç—å—Å—è")
-- –°—Ä–∞–≤–Ω–µ–Ω–∏—è –∏–∑ –∂–∏–∑–Ω–∏
-- –ù–µ–º–Ω–æ–≥–æ —é–º–æ—Ä–∞ –∏–ª–∏ –∏—Ä–æ–Ω–∏–∏ –≥–¥–µ —É–º–µ—Å—Ç–Ω–æ
-
-–ú–∞–∫—Å–∏–º—É–º 500 —Å–∏–º–≤–æ–ª–æ–≤. –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π –∑–∞–µ–∑–∂–µ–Ω–Ω—ã–µ —Ñ—Ä–∞–∑—ã."""
-        
-        if image_description:
-            user_prompt = f"–ù–∞–ø–∏—à–∏ –ø–æ—Å—Ç-—Ä–∞–∑–º—ã—à–ª–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ —Ç–µ–º—ã.\n–¢–µ–º–∞: {title}\n–û–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {image_description}"
-        else:
-            user_prompt = f"–ù–∞–ø–∏—à–∏ –ø–æ—Å—Ç-—Ä–∞–∑–º—ã—à–ª–µ–Ω–∏–µ –æ: {title}"
-    else:
-        # –£–ª—É—á—à–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –æ–±—ã—á–Ω—ã—Ö –ø–æ—Å—Ç–æ–≤ —Å —ç–º–æ–¥–∑–∏
-        system_prompt = """–¢—ã ‚Äî –∞–≤—Ç–æ—Ä Telegram-–∫–∞–Ω–∞–ª–∞ –ø—Ä–æ –∫—Ä–æ—Å—Å–æ–≤–∫–∏ –∏ —É–ª–∏—á–Ω—É—é –º–æ–¥—É. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –ø–∏—Å–∞—Ç—å –∫–æ—Ä–æ—Ç–∫–∏–µ, —Ü–µ–ø–ª—è—é—â–∏–µ –∏ —Å—Ç–∏–ª—å–Ω—ã–µ –ø–æ—Å—Ç—ã –æ —Ä–µ–ª–∏–∑–∞—Ö, —Ç—Ä–µ–Ω–¥–∞—Ö –∏ –∫–æ–ª–ª–∞–±–æ—Ä–∞—Ü–∏—è—Ö. 
-
-–ü–†–ê–í–ò–õ–ê –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø –≠–ú–û–î–ó–ò:
-- –¢–û–õ–¨–ö–û –æ–¥–∏–Ω —ç–º–æ–¥–∑–∏ –≤ –Ω–∞—á–∞–ª–µ –ø–æ—Å—Ç–∞ (–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ/—Ç–µ–º–∞)
-- –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –û–î–ò–ù —ç–º–æ–¥–∑–∏ –≤ –∫–æ–Ω—Ü–µ (–ø—Ä–∏–∑—ã–≤/–≤–æ–ø—Ä–æ—Å)
-- –ù–ï –∏—Å–ø–æ–ª—å–∑—É–π —ç–º–æ–¥–∑–∏ –≤–Ω—É—Ç—Ä–∏ —Ç–µ–∫—Å—Ç–∞
-- –ù–ï –∏—Å–ø–æ–ª—å–∑—É–π —ç–º–æ–¥–∑–∏ –≤ –∫–∞–∂–¥–æ–º –∞–±–∑–∞—Ü–µ
-- –ü–æ–¥—Ö–æ–¥—è—â–∏–µ —ç–º–æ–¥–∑–∏ –¥–ª—è –Ω–∞—á–∞–ª–∞: üî• ‚ö°Ô∏è üí´ üëü üö®
-- –ü–æ–¥—Ö–æ–¥—è—â–∏–µ –¥–ª—è –∫–æ–Ω—Ü–∞: üëÄ ü§î üí≠
-
-–ü–∏—à–∏ –≤ –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ-–º–æ–ª–æ–¥—ë–∂–Ω–æ–º —Ç–æ–Ω–µ: –±–µ–∑ –ø–∞—Ñ–æ—Å–∞, –±–µ–∑ –∫–∞–Ω—Ü–µ–ª—è—Ä–∏—Ç–∞, –±–µ–∑ –∂–∞—Ä–≥–æ–Ω–∞. –°—Ç–∏–ª—å ‚Äî –∂–∏–≤–æ–π, –ª—ë–≥–∫–∏–π, —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π.
-
-–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ—Å—Ç–∞:
-1. –ù–∞—á–Ω–∏ —Å –û–î–ù–û–ì–û —ç–º–æ–¥–∑–∏ –∏ —Ü–µ–ø–ª—è—é—â–µ–π —Ñ—Ä–∞–∑—ã (1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)
-2. –°—É—Ç—å —Ä–µ–ª–∏–∑–∞: –±—Ä–µ–Ω–¥, –º–æ–¥–µ–ª—å, –¥–∞—Ç–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å) - –ë–ï–ó —ç–º–æ–¥–∑–∏
-3. –≠—Å—Ç–µ—Ç–∏–∫–∞: –º–∞—Ç–µ—Ä–∏–∞–ª—ã, —Ü–≤–µ—Ç–∞, —á—Ç–æ —Ü–µ–ø–ª—è–µ—Ç - –ë–ï–ó —ç–º–æ–¥–∑–∏
-4. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ: –º–Ω–µ–Ω–∏–µ –∏–ª–∏ –≤–æ–ø—Ä–æ—Å (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –û–î–ò–ù —ç–º–æ–¥–∑–∏ –≤ –∫–æ–Ω—Ü–µ)
-
-–ò–∑–±–µ–≥–∞–π: –¥–ª–∏–Ω–Ω—ã—Ö —Ç–µ–∫—Å—Ç–æ–≤, —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –¥–µ—Ç–∞–ª–µ–π, —Ä–µ–∫–ª–∞–º–Ω—ã—Ö –∫–ª–∏—à–µ.
-–ú–∞–∫—Å–∏–º—É–º 600 —Å–∏–º–≤–æ–ª–æ–≤."""
-        
-        user_prompt = f"–ó–∞–≥–æ–ª–æ–≤–æ–∫: {title}\n–î–µ—Ç–∞–ª–∏: {context[:500] if context else '–ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏'}"
-    
-    models = ["gpt-4o", "gpt-4-turbo", "gpt-4", "gpt-3.5-turbo"]
-    
-    for model in models:
-        try:
-            logging.info(f"–ì–µ–Ω–µ—Ä–∏—Ä—É—é {'–º—ã—Å–ª–∏' if is_thought else '–æ–ø–∏—Å–∞–Ω–∏–µ'} –¥–ª—è: {title[:50]}... —Å –º–æ–¥–µ–ª—å—é {model}")
-            response = await openai_client.chat.completions.create(
-                model=model,
-                temperature=0.9 if is_thought else 0.8,
-                max_tokens=300,
-                messages=[
-                    {"role": "system", "content": system_prompt},
-                    {"role": "user", "content": user_prompt}
-                ],
-            )
-            generated = response.choices[0].message.content.strip()
-            logging.info(f"{'–ú—ã—Å–ª–∏' if is_thought else '–û–ø–∏—Å–∞–Ω–∏–µ'} —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã —É—Å–ø–µ—à–Ω–æ")
-            
-            # –î–ª—è –º—ã—Å–ª–µ–π –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
-            if not is_thought and title.lower() not in generated.lower():
-                generated = f"<b>{title}</b>\n\n{generated}"
-            
-            return generated if generated else f"<b>{title}</b>\n\nüî• –ù–æ–≤—ã–π —Ä–µ–ª–∏–∑. –ü–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ —Å–∫–æ—Ä–æ!"
-            
-        except Exception as e:
-            logging.error(f"–û—à–∏–±–∫–∞ —Å –º–æ–¥–µ–ª—å—é {model}: {type(e).__name__}: {str(e)}")
-            continue
-    
-    logging.error("–í—Å–µ –º–æ–¥–µ–ª–∏ OpenAI –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã")
-    return f"<b>{title}</b>\n\nüëü –ù–æ–≤—ã–π —Ä–µ–ª–∏–∑. –°–ª–µ–¥–∏—Ç–µ –∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏!"
 
 def build_media_group(record: dict, for_channel: bool = False) -> list:
     """–°–æ–∑–¥–∞–Ω–∏–µ –º–µ–¥–∏–∞-–≥—Ä—É–ø–ø—ã —Å —É—á–µ—Ç–æ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"""
     # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
     generated_images = state.get("generated_images", {}).get(record["id"], [])
     
     # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ
     if generated_images:
         images = generated_images + record.get("original_images", [])
     else:
         images = record.get("images") or []
     
     caption = record.get("description") or record.get("context") or record.get("title") or ""
     
     if for_channel:
-        hashtags = get_hashtags(record.get("title", ""), record.get("category", "sneakers"))
+        hashtags = utils.get_hashtags(record.get("title", ""), record.get("category", "sneakers"))
         source_text = f"\n\nüìç {record.get('source', 'Unknown')}"
         category_emoji = "üëü" if record.get("category") == "sneakers" else "üëî"
         
         # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏ –µ—Å–ª–∏ –µ—Å—Ç—å
         schedule_info = ""
         if record.get("scheduled_time"):
             schedule_info = f"\n‚è∞ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ: {record['scheduled_time']}"
         
         if len(caption) + len(record['link']) + len(source_text) + len(hashtags) + len(schedule_info) + 50 < 1024:
             caption += f"{source_text}\n{category_emoji} <a href=\"{record['link']}\">–ß–∏—Ç–∞—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é</a>{schedule_info}\n\n{hashtags}"
         elif len(caption) + len(hashtags) + 20 < 1024:
             caption += f"\n\n{hashtags}"
     
     caption = caption[:1020] + "..." if len(caption) > 1024 else caption
     media = []
     
     if images:
         # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
-        images_to_use = images[:MAX_IMAGES_PER_POST]
+        images_to_use = images[:config.MAX_IMAGES_PER_POST]
         
         media.append(InputMediaPhoto(
             media=images_to_use[0],
             caption=caption,
             parse_mode=ParseMode.HTML
         ))
         for url in images_to_use[1:]:
             media.append(InputMediaPhoto(media=url))
     
     return media
 
 async def send_preview(bot, record: dict, chat_id: int, current_idx: int, total: int, message_id=None):
     """–û—Ç–ø—Ä–∞–≤–∫–∞ –ø—Ä–µ–≤—å—é –ø–æ—Å—Ç–∞ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏ –∏ —Ç–µ–≥–∞–º–∏"""
     category_emoji = "üëü" if record.get("category") == "sneakers" else "üëî"
-    date_str = format_date_for_display(record.get("timestamp", ""))
+    date_str = utils.format_date_for_display(record.get("timestamp", ""))
     
     # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
     has_generated = record.get("id") in state.get("generated_images", {})
     is_favorite = record.get("id") in state.get("favorites", [])
     
     # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
     generated_count = len(state.get("generated_images", {}).get(record["id"], []))
     original_count = len(record.get("images", []))
     total_images = generated_count + original_count if has_generated else original_count
     
     # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–≥–∏
     tags = record.get("tags", {})
     # –ï—Å–ª–∏ —É —Å—Ç–∞—Ä–æ–≥–æ –ø–æ—Å—Ç–∞ –Ω–µ—Ç —Ç–µ–≥–æ–≤, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏—Ö
     if not tags and "title" in record:
-        tags = extract_tags(record.get("title", ""), record.get("context", ""))
+        tags = utils.extract_tags(record.get("title", ""), record.get("context", ""))
         # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–≥–∏ –≤ –∑–∞–ø–∏—Å—å
         if record["id"] in state["pending"]:
             state["pending"][record["id"]]["tags"] = tags
             save_state()
     
     tags_display = format_tags_for_display(tags)
     
     preview_text = (
         f"üìÖ <b>{date_str}</b>\n"
         f"{category_emoji} <b>{record['title']}</b>\n\n"
     )
     
     if tags_display:
         preview_text += f"{tags_display}\n\n"
     
     preview_text += (
         f"üìç –ò—Å—Ç–æ—á–Ω–∏–∫: {record.get('source', 'Unknown')}\n"
         f"üîó <a href=\"{record['link']}\">–°—Å—ã–ª–∫–∞ –Ω–∞ —Å—Ç–∞—Ç—å—é</a>\n"
         f"üñº –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {total_images}\n"
     )
     
     if has_generated:
         preview_text += f"üé® –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: {generated_count}\n"
     
     if is_favorite:
@@ -1071,51 +164,51 @@ async def send_preview(bot, record: dict, chat_id: int, current_idx: int, total:
                 reply_markup=keyboard,
                 disable_web_page_preview=True
             )
     except BadRequest as e:
         if "message is not modified" in str(e):
             # –°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
             pass
         else:
             logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø—Ä–µ–≤—å—é: {e}")
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø—Ä–µ–≤—å—é: {e}")
         return None
 
 async def send_full_post(bot, record: dict, chat_id: int):
     """–û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–ª–Ω–æ–≥–æ –ø–æ—Å—Ç–∞ —Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π –æ–ø–∏—Å–∞–Ω–∏—è"""
     loading_msg = await bot.send_message(
         chat_id,
         "‚è≥ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –æ–ø–∏—Å–∞–Ω–∏–µ –∏ –∑–∞–≥—Ä—É–∂–∞—é –ø–æ–ª–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç...",
         parse_mode=ParseMode.HTML
     )
     
     try:
         # –ü–∞—Ä—Å–∏–º –ø–æ–ª–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
         if record.get("needs_parsing"):
             async with httpx.AsyncClient(timeout=30, follow_redirects=True) as client:
-                record = await parse_full_content(client, record)
+                record = await fetcher.parse_full_content(client, record)
                 if record["id"] in state["pending"]:
                     state["pending"][record["id"]] = record
                     save_state()
         
         # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
         if not record.get("description") or record.get("description") == record.get("title"):
             description = await gen_caption(
                 record["title"], 
                 record.get("context", ""), 
                 record.get("category", "sneakers")
             )
             record["description"] = description
             # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ state
             if record["id"] in state["pending"]:
                 state["pending"][record["id"]]["description"] = description
                 save_state()
         
         # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ
         await bot.delete_message(chat_id, loading_msg.message_id)
         
         # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ—Å—Ç –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é
         await send_for_moderation(bot, record, show_all=False)
         
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–æ–ª–Ω–æ–≥–æ –ø–æ—Å—Ç–∞: {e}")
@@ -1148,191 +241,191 @@ async def send_for_moderation(bot, record: dict, show_all: bool = False):
     back_data = f"back_preview:{record['id']}"
     gen_cover_data = f"gen_cover_full:{record['id']}"
     revert_img_data = f"revert_img:{record['id']}"
     custom_prompt_data = f"custom_prompt:{record['id']}"
     
     keyboard_buttons = [
         [InlineKeyboardButton("‚úÖ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data=approve_data)],
         [InlineKeyboardButton("üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç", callback_data=regenerate_data)],
         [
             InlineKeyboardButton("üé® –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–±–ª–æ–∂–∫—É", callback_data=gen_cover_data),
             InlineKeyboardButton("‚úèÔ∏è –°–≤–æ–π –ø—Ä–æ–º–ø—Ç", callback_data=custom_prompt_data)
         ],
         [
             InlineKeyboardButton("‚Ü©Ô∏è –í–µ—Ä–Ω—É—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª", callback_data=revert_img_data),
             InlineKeyboardButton("‚ùå –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data=reject_data)
         ],
         [
             InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –ø—Ä–µ–≤—å—é", callback_data=back_data),
             InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="cmd_back_main")
         ]
     ]
     
     keyboard = InlineKeyboardMarkup(keyboard_buttons)
     
     category_emoji = "üëü" if record.get("category") == "sneakers" else "üëî"
-    date_str = format_date_for_display(record.get("timestamp", ""))
-    hashtags = get_hashtags(record.get("title", ""), record.get("category", "sneakers"))
+    date_str = utils.format_date_for_display(record.get("timestamp", ""))
+    hashtags = utils.get_hashtags(record.get("title", ""), record.get("category", "sneakers"))
     source_info = f"\nüìç –ò—Å—Ç–æ—á–Ω–∏–∫: {record.get('source', 'Unknown')}"
     link_info = f"\nüîó –°—Ç–∞—Ç—å—è: {record['link']}"
     
     # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è—Ö
     img_info = ""
     generated_count = len(state.get("generated_images", {}).get(record["id"], []))
     original_count = len(record.get("images", []))
     
     if generated_count > 0:
         img_info = f"\nüé® –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: {generated_count}, –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã—Ö: {original_count}"
     else:
         img_info = f"\nüñº –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {original_count}"
     
     text = (f"üìÖ {date_str}\n"
            f"{category_emoji} <b>{record['title']}</b>\n\n"
            f"{record['description'][:400]}"
            f"{source_info}{link_info}{img_info}\n\n"
            f"{hashtags}\n\n"
            f"üÜî ID: {record['id']}")
     
     try:
         media = build_media_group(record, for_channel=False)
         if media:
-            await bot.send_media_group(ADMIN_CHAT_ID, media)
+            await bot.send_media_group(config.ADMIN_CHAT_ID, media)
             await bot.send_message(
-                ADMIN_CHAT_ID,
+                config.ADMIN_CHAT_ID,
                 text,
                 reply_markup=keyboard,
                 parse_mode=ParseMode.HTML,
                 disable_web_page_preview=True
             )
         else:
             await bot.send_message(
-                ADMIN_CHAT_ID,
+                config.ADMIN_CHAT_ID,
                 text,
                 parse_mode=ParseMode.HTML,
                 reply_markup=keyboard,
                 disable_web_page_preview=True
             )
         return True
     except TelegramError as e:
         logging.error(f"–û—à–∏–±–∫–∞ Telegram –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é: {e}")
         return False
     except Exception as e:
         logging.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é: {e}")
         return False
 
 async def publish_release(bot, record: dict):
     logging.info(f"–ü—É–±–ª–∏–∫—É—é –≤ –∫–∞–Ω–∞–ª: {record['title'][:50]}...")
     
     # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –∫–∞–Ω–∞–ª –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
-    channel = state.get("channel", TELEGRAM_CHANNEL)
+    channel = state.get("channel", config.TELEGRAM_CHANNEL)
     
     try:
         media = build_media_group(record, for_channel=True)
         if media:
             await bot.send_media_group(channel, media)
         else:
             category_emoji = "üëü" if record.get("category") == "sneakers" else "üëî"
-            hashtags = get_hashtags(record.get("title", ""), record.get("category", "sneakers"))
+            hashtags = utils.get_hashtags(record.get("title", ""), record.get("category", "sneakers"))
             
             # –î–æ–±–∞–≤–ª—è–µ–º —ç–º–æ–¥–∑–∏ –¥–ª—è –∏—Å—Ç–æ—á–Ω–∏–∫–∞
             source_emojis = {
                 "SneakerNews": "üì∞",
                 "Hypebeast": "üî•",
                 "Highsnobiety": "üíé",
                 "Hypebeast Footwear": "üëü",
                 "Hypebeast Fashion": "üëî",
                 "Highsnobiety Sneakers": "‚ú®",
                 "Highsnobiety Fashion": "üé®"
             }
             source_emoji = source_emojis.get(record.get('source', ''), "üìç")
             source_text = f"\n\n{source_emoji} {record.get('source', 'Unknown')}"
             
             text = (f"{category_emoji} <b>{record['title']}</b>\n\n"
                    f"{record['description']}{source_text}\n\n"
                    f"üîó <a href=\"{record['link']}\">–ß–∏—Ç–∞—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é</a>\n\n"
                    f"{hashtags}")
             await bot.send_message(
                 channel,
                 text,
                 parse_mode=ParseMode.HTML
             )
         return True
     except TelegramError as e:
         logging.error(f"–û—à–∏–±–∫–∞ Telegram –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {e}")
         return False
     except Exception as e:
         logging.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {e}")
         return False
 
 async def check_releases_job(context: ContextTypes.DEFAULT_TYPE):
     bot = context.bot
     
     try:
         # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –∞–¥–º–∏–Ω
-        if not ADMIN_CHAT_ID:
-            logging.warning("ADMIN_CHAT_ID –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É")
+        if not config.ADMIN_CHAT_ID:
+            logging.warning("config.ADMIN_CHAT_ID –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É")
             return
             
         # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
         progress_msg = await bot.send_message(
-            ADMIN_CHAT_ID,
+            config.ADMIN_CHAT_ID,
             "üîÑ –ù–∞—á–∏–Ω–∞—é –ø—Ä–æ–≤–µ—Ä–∫—É –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤...",
             parse_mode=ParseMode.HTML
         )
         
         # –ò—â–µ–º –Ω–æ–≤—ã–µ —Ä–µ–ª–∏–∑—ã —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
         logging.info("–ò—â—É –Ω–æ–≤—ã–µ —Ä–µ–ª–∏–∑—ã...")
         async with httpx.AsyncClient(timeout=30, follow_redirects=True) as client:
-            new_releases = await fetch_releases(client, progress_msg, bot)
+            new_releases = await fetcher.fetch_releases(client, progress_msg, bot)
         
         if not new_releases:
             await bot.edit_message_text(
                 "üì≠ –ù–æ–≤—ã—Ö —Ä–µ–ª–∏–∑–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ",
                 progress_msg.chat.id,
                 progress_msg.message_id
             )
             return
         
         # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Ä–µ–ª–∏–∑—ã –≤ pending
         added_count = 0
         for rel in new_releases:
             try:
                 if rel["id"] not in state["pending"]:
                     state["pending"][rel["id"]] = rel
                     added_count += 1
             except Exception as e:
                 logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ä–µ–ª–∏–∑–∞: {e}")
                 continue
         
         if added_count > 0:
             save_state()
             logging.info(f"–î–æ–±–∞–≤–ª–µ–Ω–æ {added_count} –Ω–æ–≤—ã—Ö –ø–æ—Å—Ç–æ–≤ –≤ –æ—á–µ—Ä–µ–¥—å")
             
             # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ—Å—Ç—ã –ø–æ –¥–∞—Ç–∞–º
             posts_by_date = {}
             for post in state["pending"].values():
-                date_str = format_date_for_display(post.get("timestamp", ""))
+                date_str = utils.format_date_for_display(post.get("timestamp", ""))
                 if date_str not in posts_by_date:
                     posts_by_date[date_str] = []
                 posts_by_date[date_str].append(post)
             
             # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
             summary = f"üÜï –ù–∞–π–¥–µ–Ω–æ <b>{added_count}</b> –Ω–æ–≤—ã—Ö –ø–æ—Å—Ç–æ–≤!\n\n"
             
             for date, posts in sorted(posts_by_date.items()):
                 summary += f"üìÖ <b>{date}</b> ({len(posts)} –ø–æ—Å—Ç–æ–≤)\n"
                 # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞–º
                 by_source = {}
                 for post in posts:
                     src = post.get("source", "Unknown")
                     if src not in by_source:
                         by_source[src] = 0
                     by_source[src] += 1
                 
                 for src, count in by_source.items():
                     summary += f"  ‚Ä¢ {src}: {count}\n"
                 summary += "\n"
             
             summary += f"üìä –í—Å–µ–≥–æ –≤ –æ—á–µ—Ä–µ–¥–∏: {len(state['pending'])}\n\n"
             summary += "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /preview –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞"
             
             await bot.edit_message_text(
@@ -1348,113 +441,113 @@ async def check_releases_job(context: ContextTypes.DEFAULT_TYPE):
         # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ-–ø—É–±–ª–∏–∫–∞—Ü–∏—é
         if state.get("auto_publish"):
             await auto_publish_next(bot)
                 
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –≤ check_releases_job: {e}")
 
 async def check_scheduled_posts(bot):
     """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –ø—É–±–ª–∏–∫–∞—Ü–∏—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ—Å—Ç–æ–≤"""
     now = datetime.now(timezone.utc)
     published = []
     
     for post_id, schedule_info in list(state.get("scheduled_posts", {}).items()):
         try:
             scheduled_time = datetime.fromisoformat(schedule_info["time"].replace('Z', '+00:00'))
             if now >= scheduled_time:
                 # –ü—É–±–ª–∏–∫—É–µ–º –ø–æ—Å—Ç
                 record = schedule_info["record"]
                 success = await publish_release(bot, record)
                 
                 if success:
                     published.append(post_id)
                     logging.info(f"–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Å—Ç: {record['title'][:50]}")
                     
                     # –£–≤–µ–¥–æ–º–ª—è–µ–º –∞–¥–º–∏–Ω–∞
-                    if ADMIN_CHAT_ID:
+                    if config.ADMIN_CHAT_ID:
                         await bot.send_message(
-                            ADMIN_CHAT_ID,
+                            config.ADMIN_CHAT_ID,
                             f"‚úÖ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Å—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω:\n{record['title'][:50]}...",
                             parse_mode=ParseMode.HTML
                         )
         except Exception as e:
             logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ—Å—Ç–∞ {post_id}: {e}")
     
     # –£–¥–∞–ª—è–µ–º –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω—ã–µ –∏–∑ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö
     for post_id in published:
         state["scheduled_posts"].pop(post_id, None)
         # –£–¥–∞–ª—è–µ–º –∏–∑ pending
         state["pending"].pop(post_id, None)
         # –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ
         record = state["scheduled_posts"].get(post_id, {}).get("record", {})
         if record.get("link"):
             state["sent_links"].append(record["link"])
     
     if published:
         save_state()
 
 async def auto_publish_next(bot):
     """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—É–±–ª–∏–∫–∞—Ü–∏—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–æ—Å—Ç–∞ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ"""
     if not state.get("auto_publish"):
         return
     
     # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–≥–¥–∞ –±—ã–ª–∞ –ø–æ—Å–ª–µ–¥–Ω—è—è –ø—É–±–ª–∏–∫–∞—Ü–∏—è
     last_publish = state.get("last_auto_publish")
     if last_publish:
         last_time = datetime.fromisoformat(last_publish.replace('Z', '+00:00'))
         interval = state.get("publish_interval", 3600)
         if (datetime.now(timezone.utc) - last_time).seconds < interval:
             return
     
     # –ò—â–µ–º –ø–æ—Å—Ç –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
     favorites = state.get("favorites", [])
     for fav_id in favorites:
         if fav_id in state["pending"]:
             record = state["pending"][fav_id]
             success = await publish_release(bot, record)
             
             if success:
                 # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                 state["last_auto_publish"] = datetime.now(timezone.utc).isoformat()
                 state["favorites"].remove(fav_id)
                 state["pending"].pop(fav_id, None)
                 state["sent_links"].append(record["link"])
                 save_state()
                 
-                if ADMIN_CHAT_ID:
+                if config.ADMIN_CHAT_ID:
                     await bot.send_message(
-                        ADMIN_CHAT_ID,
+                        config.ADMIN_CHAT_ID,
                         f"ü§ñ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –ø–æ—Å—Ç –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ:\n{record['title'][:50]}...",
                         parse_mode=ParseMode.HTML
                     )
                 break
 
 async def thoughts_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Å—Ç–∞-—Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è"""
     try:
         user_id = update.message.from_user.id
-        if ADMIN_CHAT_ID and user_id != ADMIN_CHAT_ID:
+        if config.ADMIN_CHAT_ID and user_id != config.ADMIN_CHAT_ID:
             await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
             return
         
         # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã
         if not context.args:
             await update.message.reply_text(
                 "üí≠ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                 "/thoughts <–∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ>\n\n"
                 "–ü—Ä–∏–º–µ—Ä:\n"
                 "/thoughts –Ω–æ–≤—ã–µ Jordan 4 –≤ —á–µ—Ä–Ω–æ–º —Ü–≤–µ—Ç–µ\n\n"
                 "–¢–∞–∫–∂–µ –º–æ–∂–Ω–æ –ø—Ä–∏–∫—Ä–µ–ø–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ!"
             )
             return
         
         # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–º—É
         topic = " ".join(context.args)
         
         # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ state –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
         state["waiting_for_image"] = {
             "type": "thoughts",
             "topic": topic,
             "message_id": update.message.message_id
         }
         save_state()
         
@@ -1463,388 +556,388 @@ async def thoughts_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
             "üí≠ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /skip —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç –±–µ–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"
         )
         
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –≤ thoughts_command: {e}")
         await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏")
 
 async def skip_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –æ–∂–∏–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
     if state.get("waiting_for_image"):
         waiting_data = state["waiting_for_image"]
         state["waiting_for_image"] = None
         save_state()
         
         if waiting_data["type"] == "thoughts":
             # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –º—ã—Å–ª–∏ –±–µ–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
             msg = await update.message.reply_text("üí≠ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –º—ã—Å–ª–∏...")
             
             thought_text = await gen_caption(
                 waiting_data["topic"], 
                 "", 
                 "sneakers", 
                 is_thought=True
             )
             
-            hashtags = get_hashtags(waiting_data["topic"], "sneakers")
+            hashtags = utils.get_hashtags(waiting_data["topic"], "sneakers")
             final_text = f"{thought_text}\n\n{hashtags}"
             
             keyboard = InlineKeyboardMarkup([
                 [InlineKeyboardButton("üì§ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data="publish_thought")],
                 [InlineKeyboardButton("üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="regen_thought")],
                 [InlineKeyboardButton("üé® –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–±–ª–æ–∂–∫—É", callback_data="gen_thought_cover")],
                 [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_thought")]
             ])
             
             state["current_thought"] = {
                 "text": final_text,
                 "topic": waiting_data["topic"]
             }
             save_state()
             
             await msg.edit_text(
                 f"üí≠ <b>–ü–æ—Å—Ç-—Ä–∞–∑–º—ã—à–ª–µ–Ω–∏–µ:</b>\n\n{final_text}",
                 parse_mode=ParseMode.HTML,
                 reply_markup=keyboard
             )
 
 async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π"""
     try:
         if not state.get("waiting_for_image"):
             return
         
         user_id = update.message.from_user.id
-        if ADMIN_CHAT_ID and user_id != ADMIN_CHAT_ID:
+        if config.ADMIN_CHAT_ID and user_id != config.ADMIN_CHAT_ID:
             return
         
         waiting_data = state["waiting_for_image"]
         state["waiting_for_image"] = None
         save_state()
         
         # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å
         msg = await update.message.reply_text("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...")
         
         # –ü–æ–ª—É—á–∞–µ–º —Ñ–æ—Ç–æ
         photo = update.message.photo[-1]  # –ë–µ—Ä–µ–º —Å–∞–º–æ–µ –±–æ–ª—å—à–æ–µ
         file = await context.bot.get_file(photo.file_id)
         
         # –°–∫–∞—á–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
         image_bytes = await file.download_as_bytearray()
         
         # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
         image_description = await analyze_image(bytes(image_bytes))
         
         if waiting_data["type"] == "thoughts":
             # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –º—ã—Å–ª–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
             await msg.edit_text("üí≠ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –º—ã—Å–ª–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...")
             
             thought_text = await gen_caption(
                 waiting_data["topic"], 
                 "", 
                 "sneakers", 
                 is_thought=True,
                 image_description=image_description
             )
             
-            hashtags = get_hashtags(waiting_data["topic"], "sneakers")
+            hashtags = utils.get_hashtags(waiting_data["topic"], "sneakers")
             final_text = f"{thought_text}\n\n{hashtags}"
             
             # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ Telegram –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
             uploaded_photo = await update.message.photo[-1].get_file()
             photo_url = uploaded_photo.file_path
             
             keyboard = InlineKeyboardMarkup([
                 [InlineKeyboardButton("üì§ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data="publish_thought")],
                 [InlineKeyboardButton("üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="regen_thought")],
                 [InlineKeyboardButton("üé® –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–±–ª–æ–∂–∫—É", callback_data="gen_thought_cover")],
                 [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_thought")]
             ])
             
             state["current_thought"] = {
                 "text": final_text,
                 "topic": waiting_data["topic"],
                 "image_description": image_description,
                 "image_url": photo.file_id  # –°–æ—Ö—Ä–∞–Ω—è–µ–º file_id –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
             }
             save_state()
             
             await msg.edit_text(
                 f"üí≠ <b>–ü–æ—Å—Ç-—Ä–∞–∑–º—ã—à–ª–µ–Ω–∏–µ:</b>\n\n{final_text}\n\n"
                 f"üì∏ –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω–æ",
                 parse_mode=ParseMode.HTML,
                 reply_markup=keyboard
             )
         
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–æ—Ç–æ: {e}")
         await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
 
 async def on_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
     query = update.callback_query
     await query.answer()
     
     try:
         data = query.data
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ –∏–∑ –º–µ–Ω—é
         if data.startswith("cmd_"):
             if data == "cmd_status":
                 await show_status_info(query)
                 return
             elif data == "cmd_help":
                 await show_help_info(query)
                 return
             elif data == "cmd_preview":
-                if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+                if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                     await query.edit_message_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                     return
                 await start_preview_mode(query, context)
                 return
             elif data == "cmd_check":
-                if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+                if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                     await query.edit_message_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                     return
                 await query.edit_message_text("üîÑ –ó–∞–ø—É—Å–∫–∞—é –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–æ–≤—ã—Ö —Ä–µ–ª–∏–∑–æ–≤...")
                 asyncio.create_task(check_releases_job(context))
                 return
             elif data == "cmd_thoughts":
-                if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+                if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                     await query.edit_message_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                     return
                 await show_thoughts_prompt(query)
                 return
             elif data == "cmd_scheduled":
-                if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+                if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                     await query.edit_message_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                     return
                 await show_scheduled_posts(query)
                 return
             elif data == "cmd_stats":
                 await show_stats_info(query)
                 return
             elif data == "cmd_clean_menu":
-                if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+                if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                     await query.edit_message_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                     return
                 await show_clean_menu(query)
                 return
             elif data == "cmd_tools_menu":
-                if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+                if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                     await query.edit_message_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                     return
                 await show_tools_menu(query)
                 return
             elif data == "cmd_back_main":
                 await show_main_menu(query)
                 return
             elif data == "cmd_auto_menu":
-                if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+                if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                     await query.edit_message_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                     return
                 await show_auto_publish_menu(query)
                 return
             elif data == "cmd_settings":
-                if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+                if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                     await query.edit_message_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
                     return
                 await show_settings_menu(query)
                 return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫
         if data.startswith("settings_"):
-            if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+            if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                 await query.edit_message_text("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤")
                 return
                 
             if data == "settings_channel":
                 state["waiting_for_channel"] = True
                 save_state()
                 await query.edit_message_text(
                     "üì¢ <b>–ò–∑–º–µ–Ω–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏</b>\n\n"
                     "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
                     "‚Ä¢ <code>@channelname</code> - –¥–ª—è –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞\n"
                     "‚Ä¢ <code>-1001234567890</code> - –¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞ (ID —á–∞—Ç–∞)\n\n"
-                    f"–¢–µ–∫—É—â–∏–π –∫–∞–Ω–∞–ª: <code>{state.get('channel', TELEGRAM_CHANNEL)}</code>\n\n"
+                    f"–¢–µ–∫—É—â–∏–π –∫–∞–Ω–∞–ª: <code>{state.get('channel', config.TELEGRAM_CHANNEL)}</code>\n\n"
                     "–ò–ª–∏ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã",
                     parse_mode=ParseMode.HTML
                 )
                 return
             elif data == "settings_timezone":
                 await show_timezone_menu(query)
                 return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–æ–Ω
         if data.startswith("tz_"):
-            if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+            if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                 await query.edit_message_text("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤")
                 return
                 
             timezone_name = data.replace("tz_", "").replace("_", "/")
             state["timezone"] = timezone_name
             save_state()
             
             await query.edit_message_text(
                 f"‚úÖ –í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–æ–Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ {timezone_name}\n\n"
                 f"–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è: {datetime.now(pytz.timezone(timezone_name)).strftime('%H:%M')}",
                 parse_mode=ParseMode.HTML
             )
             return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–≤—Ç–æ-–ø—É–±–ª–∏–∫–∞—Ü–∏–∏
         if data.startswith("auto_"):
-            if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+            if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                 await query.edit_message_text("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤")
                 return
             
             if data == "auto_toggle":
                 state["auto_publish"] = not state.get("auto_publish", False)
                 save_state()
                 await show_auto_publish_menu(query)
                 return
             elif data.startswith("auto_interval:"):
                 interval = int(data.split(":")[1])
                 state["publish_interval"] = interval
                 save_state()
                 await show_auto_publish_menu(query)
                 return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
         if data.startswith("toggle_fav:"):
             uid = data.split(":")[1]
             if "favorites" not in state:
                 state["favorites"] = []
             
             if uid in state["favorites"]:
                 state["favorites"].remove(uid)
             else:
                 state["favorites"].append(uid)
             
             save_state()
             
             # –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–µ–≤—å—é
             preview_list = state.get("preview_mode", {}).get("list", [])
             if uid in preview_list:
                 idx = preview_list.index(uid)
                 record = state["pending"].get(uid)
                 if record:
                     await send_preview(
                         context.bot,
                         record,
                         query.message.chat.id,
                         idx,
                         len(preview_list),
                         query.message.message_id
                     )
             return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–Ω—é –æ—á–∏—Å—Ç–∫–∏
         if data.startswith("clean_"):
-            if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+            if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                 await query.edit_message_text("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤")
                 return
                 
             if data == "clean_old":
                 before_count = len(state["pending"])
                 removed = clean_old_posts(state)
                 after_count = len(state["pending"])
                 save_state()
                 
                 await query.edit_message_text(
                     f"üóë <b>–û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞:</b>\n\n"
                     f"–ë—ã–ª–æ –ø–æ—Å—Ç–æ–≤: {before_count}\n"
                     f"–£–¥–∞–ª–µ–Ω–æ —Å—Ç–∞—Ä—ã—Ö: {removed}\n"
                     f"–û—Å—Ç–∞–ª–æ—Å—å: {after_count}\n\n"
                     f"–£–¥–∞–ª—è—é—Ç—Å—è –ø–æ—Å—Ç—ã —Å—Ç–∞—Ä—à–µ {MAX_POST_AGE_DAYS} –¥–Ω–µ–π",
                     parse_mode=ParseMode.HTML
                 )
                 return
             elif data == "clean_pending":
                 count = len(state["pending"])
                 state["pending"].clear()
                 state["preview_mode"].clear()
                 state["generated_images"].clear()
                 save_state()
                 
                 await query.edit_message_text(f"üóë –û—á–∏—â–µ–Ω–æ {count} –ø–æ—Å—Ç–æ–≤ –∏–∑ –æ—á–µ—Ä–µ–¥–∏")
                 return
             elif data == "clean_sent":
                 count = len(state["sent_links"])
                 state["sent_links"].clear()
                 save_state()
                 
                 await query.edit_message_text(f"üóë –û—á–∏—â–µ–Ω —Å–ø–∏—Å–æ–∫ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö: {count} –∑–∞–ø–∏—Å–µ–π")
                 return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–Ω—é –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
         if data.startswith("tool_"):
-            if ADMIN_CHAT_ID and query.from_user.id != ADMIN_CHAT_ID:
+            if config.ADMIN_CHAT_ID and query.from_user.id != config.ADMIN_CHAT_ID:
                 await query.edit_message_text("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤")
                 return
                 
             if data == "tool_test_sources":
                 await query.edit_message_text("üîç –¢–µ—Å—Ç–∏—Ä—É—é –∏—Å—Ç–æ—á–Ω–∏–∫–∏...")
                 await test_sources_inline(query, context)
                 return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
         if data.startswith("schedule:"):
             uid = data.split(":")[1]
             state["waiting_for_schedule"] = uid
             save_state()
             
             user_tz = get_user_timezone()
             await query.edit_message_text(
                 f"‚è∞ <b>–ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏</b>\n\n"
-                f"–í–∞—à–∞ –≤—Ä–µ–º–µ–Ω–Ω–∞—è –∑–æ–Ω–∞: {state.get('timezone', DEFAULT_TIMEZONE)}\n"
+                f"–í–∞—à–∞ –≤—Ä–µ–º–µ–Ω–Ω–∞—è –∑–æ–Ω–∞: {state.get('timezone', config.DEFAULT_TIMEZONE)}\n"
                 f"–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è: {datetime.now(user_tz).strftime('%H:%M')}\n\n"
                 f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤—Ä–µ–º—è –≤ –æ–¥–Ω–æ–º –∏–∑ —Ñ–æ—Ä–º–∞—Ç–æ–≤:\n"
                 f"‚Ä¢ <code>18:30</code> - —Å–µ–≥–æ–¥–Ω—è –≤ 18:30\n"
                 f"‚Ä¢ <code>25.12 15:00</code> - –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –¥–∞—Ç–∞\n"
                 f"‚Ä¢ <code>+2h</code> - —á–µ—Ä–µ–∑ 2 —á–∞—Å–∞\n"
                 f"‚Ä¢ <code>+30m</code> - —á–µ—Ä–µ–∑ 30 –º–∏–Ω—É—Ç\n"
                 f"‚Ä¢ <code>+1d</code> - —á–µ—Ä–µ–∑ 1 –¥–µ–Ω—å\n\n"
                 f"–ò–ª–∏ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã",
                 parse_mode=ParseMode.HTML
             )
             return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
         if data.startswith("edit_schedule:"):
             post_id = data.split(":")[1]
             state["editing_schedule"] = post_id
             save_state()
             
             schedule_info = state["scheduled_posts"].get(post_id)
             if schedule_info:
                 scheduled_time = datetime.fromisoformat(schedule_info["time"].replace('Z', '+00:00'))
                 local_time = localize_datetime(scheduled_time)
                 user_tz = get_user_timezone()
                 
                 await query.edit_message_text(
                     f"üìù <b>–ò–∑–º–µ–Ω–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏</b>\n\n"
-                    f"–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è: {local_time.strftime('%d.%m.%Y %H:%M')} ({state.get('timezone', DEFAULT_TIMEZONE)})\n"
+                    f"–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è: {local_time.strftime('%d.%m.%Y %H:%M')} ({state.get('timezone', config.DEFAULT_TIMEZONE)})\n"
                     f"–°–µ–π—á–∞—Å: {datetime.now(user_tz).strftime('%H:%M')}\n\n"
                     f"–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
                     f"‚Ä¢ <code>18:30</code> - —Å–µ–≥–æ–¥–Ω—è –≤ 18:30\n"
                     f"‚Ä¢ <code>25.12 15:00</code> - –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –¥–∞—Ç–∞\n"
                     f"‚Ä¢ <code>+2h</code> - —á–µ—Ä–µ–∑ 2 —á–∞—Å–∞\n\n"
                     f"–ò–ª–∏ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã",
                     parse_mode=ParseMode.HTML
                 )
             return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è
         if data.startswith("delete_schedule:"):
             post_id = data.split(":")[1]
             if post_id in state.get("scheduled_posts", {}):
                 state["scheduled_posts"].pop(post_id)
                 save_state()
                 await query.edit_message_text("‚úÖ –ü–æ—Å—Ç —É–¥–∞–ª–µ–Ω –∏–∑ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è")
             return
         
         # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞
         if data.startswith("custom_prompt:"):
             uid = data.split(":")[1]
             state["waiting_for_prompt"] = uid
             save_state()
             
@@ -1994,86 +1087,86 @@ async def on_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
         
         elif data.startswith("back_preview:"):
             # –í–æ–∑–≤—Ä–∞—Ç –∫ –ø—Ä–µ–≤—å—é
             uid = data.split(":")[1]
             await query.message.delete()
             
             preview_list = state.get("preview_mode", {}).get("list", [])
             if uid in preview_list:
                 idx = preview_list.index(uid)
                 record = state["pending"].get(uid)
                 if record:
                     await send_preview(
                         context.bot,
                         record,
                         query.message.chat.id,
                         idx,
                         len(preview_list)
                     )
             return
         
         elif data == "publish_thought":
             # –ü—É–±–ª–∏–∫–∞—Ü–∏—è –º—ã—Å–ª–∏
             thought_data = state.get("current_thought")
             if thought_data:
                 try:
-                    channel = state.get("channel", TELEGRAM_CHANNEL)
+                    channel = state.get("channel", config.TELEGRAM_CHANNEL)
                     # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                     if thought_data.get("image_url"):
                         await context.bot.send_photo(
                             channel,
                             thought_data["image_url"],
                             caption=thought_data["text"],
                             parse_mode=ParseMode.HTML
                         )
                     else:
                         await context.bot.send_message(
                             channel,
                             thought_data["text"],
                             parse_mode=ParseMode.HTML
                         )
                     await query.edit_message_text("‚úÖ –ú—ã—Å–ª–∏ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω—ã!")
                     state.pop("current_thought", None)
                     save_state()
                 except Exception as e:
                     await query.edit_message_text(f"‚ùå –û—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: {e}")
             return
         
         elif data == "regen_thought":
             # –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –º—ã—Å–ª–∏
             thought_data = state.get("current_thought")
             if thought_data:
                 await query.edit_message_text("üîÑ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –Ω–æ–≤—ã–µ –º—ã—Å–ª–∏...")
                 
                 new_thought = await gen_caption(
                     thought_data["topic"], 
                     "", 
                     "sneakers", 
                     is_thought=True,
                     image_description=thought_data.get("image_description", "")
                 )
-                hashtags = get_hashtags(thought_data["topic"], "sneakers")
+                hashtags = utils.get_hashtags(thought_data["topic"], "sneakers")
                 final_text = f"{new_thought}\n\n{hashtags}"
                 
                 state["current_thought"]["text"] = final_text
                 save_state()
                 
                 keyboard = InlineKeyboardMarkup([
                     [InlineKeyboardButton("üì§ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data="publish_thought")],
                     [InlineKeyboardButton("üîÑ –ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="regen_thought")],
                     [InlineKeyboardButton("üé® –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–±–ª–æ–∂–∫—É", callback_data="gen_thought_cover")],
                     [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_thought")]
                 ])
                 
                 await query.edit_message_text(
                     f"üí≠ <b>–ü–æ—Å—Ç-—Ä–∞–∑–º—ã—à–ª–µ–Ω–∏–µ:</b>\n\n{final_text}",
                     parse_mode=ParseMode.HTML,
                     reply_markup=keyboard
                 )
             return
         
         elif data == "gen_thought_cover":
             # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–±–ª–æ–∂–∫–∏ –¥–ª—è –º—ã—Å–ª–∏
             thought_data = state.get("current_thought")
             if thought_data:
                 await query.edit_message_text("üé® –ì–µ–Ω–µ—Ä–∏—Ä—É—é –æ–±–ª–æ–∂–∫—É –¥–ª—è –º—ã—Å–ª–∏...")
                 
@@ -2153,51 +1246,51 @@ async def on_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
         elif action == "regen":
             await query.edit_message_text(f"üîÑ –†–µ–≥–µ–Ω–µ—Ä–∏—Ä—É—é –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è: {record['title'][:50]}...")
             
             context_text = record.get("context", "")
             if not context_text and "link" in record:
                 context_text = f"–†–µ–ª–∏–∑ –æ—Ç {record.get('title', '')}"
             
             new_description = await gen_caption(record["title"], context_text, record.get("category", "sneakers"))
             record["description"] = new_description
             state["pending"][uid] = record
             save_state()
             
             await send_for_moderation(context.bot, record, show_all=False)
             
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ callback: {e}")
         try:
             await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ")
         except:
             await query.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
 
 # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
 async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
     try:
         logging.info(f"–ö–æ–º–∞–Ω–¥–∞ /start –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {update.message.from_user.id}")
-        is_admin = not ADMIN_CHAT_ID or update.message.from_user.id == ADMIN_CHAT_ID
+        is_admin = not config.ADMIN_CHAT_ID or update.message.from_user.id == config.ADMIN_CHAT_ID
         
         # –ë–∞–∑–æ–≤—ã–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
         keyboard_buttons = [
             [InlineKeyboardButton("üìä –°—Ç–∞—Ç—É—Å –±–æ—Ç–∞", callback_data="cmd_status")],
             [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="cmd_help")]
         ]
         
         if is_admin:
             # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
             keyboard_buttons.extend([
                 [
                     InlineKeyboardButton("üëÅ –ü—Ä–µ–≤—å—é –ø–æ—Å—Ç–æ–≤", callback_data="cmd_preview"),
                     InlineKeyboardButton("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–ª–∏–∑—ã", callback_data="cmd_check")
                 ],
                 [
                     InlineKeyboardButton("üí≠ –°–æ–∑–¥–∞—Ç—å –º—ã—Å–ª–∏", callback_data="cmd_thoughts"),
                     InlineKeyboardButton("‚è∞ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ", callback_data="cmd_scheduled")
                 ],
                 [
                     InlineKeyboardButton("üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="cmd_stats"),
                     InlineKeyboardButton("ü§ñ –ê–≤—Ç–æ-–ø—É–±–ª–∏–∫–∞—Ü–∏—è", callback_data="cmd_auto_menu")
                 ],
                 [
                     InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="cmd_settings"),
                     InlineKeyboardButton("üßπ –û—á–∏—Å—Ç–∫–∞", callback_data="cmd_clean_menu")
@@ -2212,127 +1305,127 @@ async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
         welcome_text = (
             "üëü <b>HypeBot</b> - –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ä–µ–ª–∏–∑–æ–≤ –∫—Ä–æ—Å—Å–æ–≤–æ–∫ –∏ —É–ª–∏—á–Ω–æ–π –º–æ–¥—ã\n\n"
             "üî• –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ä–µ–ª–∏–∑—ã Nike, Adidas, Jordan –∏ –¥—Ä—É–≥–∏—Ö –±—Ä–µ–Ω–¥–æ–≤\n"
             "ü§ñ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–ø–∏—Å–∞–Ω–∏–π –∏ –æ–±–ª–æ–∂–µ–∫\n"
             "‚è∞ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –ø—É–±–ª–∏–∫–∞—Ü–∏–π\n"
             "‚≠êÔ∏è –ò–∑–±—Ä–∞–Ω–Ω–æ–µ –∏ –∞–≤—Ç–æ-–ø—É–±–ª–∏–∫–∞—Ü–∏—è\n\n"
             "–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—É—é –∫–æ–º–∞–Ω–¥—É:"
         )
         
         if is_admin:
             welcome_text += f"\n\nüîê <i>–í—ã –≤–æ—à–ª–∏ –∫–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä</i>"
         
         await update.message.reply_text(
             welcome_text,
             parse_mode=ParseMode.HTML,
             reply_markup=keyboard
         )
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –≤ start_command: {e}")
         await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
 
 async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
     try:
         user_id = update.message.from_user.id
-        if ADMIN_CHAT_ID and user_id != ADMIN_CHAT_ID:
+        if config.ADMIN_CHAT_ID and user_id != config.ADMIN_CHAT_ID:
             return
         
         text = update.message.text
         
         # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –æ–∂–∏–¥–∞–Ω–∏—è
         if state.get("waiting_for_channel"):
             # –û–∂–∏–¥–∞–µ–º –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª
             new_channel = text.strip()
             
             # –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–∞–Ω–∞–ª–∞
             if new_channel.startswith("@") or (new_channel.lstrip("-").isdigit() and len(new_channel) > 5):
                 state["channel"] = new_channel
                 state["waiting_for_channel"] = False
                 save_state()
                 
                 await update.message.reply_text(
                     f"‚úÖ –ö–∞–Ω–∞–ª –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: <code>{new_channel}</code>\n\n"
                     f"–í—Å–µ –Ω–æ–≤—ã–µ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å—Å—è –≤ —ç—Ç–æ—Ç –∫–∞–Ω–∞–ª.",
                     parse_mode=ParseMode.HTML
                 )
             else:
                 await update.message.reply_text(
                     "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–∞–Ω–∞–ª–∞\n\n"
                     "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\n"
                     "‚Ä¢ <code>@channelname</code> –¥–ª—è –ø—É–±–ª–∏—á–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞\n"
                     "‚Ä¢ <code>-1001234567890</code> –¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞",
                     parse_mode=ParseMode.HTML
                 )
         
         elif state.get("waiting_for_schedule"):
             # –û–∂–∏–¥–∞–µ–º –≤—Ä–µ–º—è –¥–ª—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
-            scheduled_time = parse_schedule_time(text)
+            scheduled_time = utils.parse_schedule_time(text)
             if scheduled_time:
                 post_id = state["waiting_for_schedule"]
                 record = state["pending"].get(post_id)
                 
                 if record:
                     state["scheduled_posts"][post_id] = {
                         "time": scheduled_time.isoformat(),
                         "record": record
                     }
                     
                     state["waiting_for_schedule"] = None
                     save_state()
                     
                     local_time = localize_datetime(scheduled_time)
                     await update.message.reply_text(
-                        f"‚úÖ –ü–æ—Å—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω –Ω–∞ {local_time.strftime('%d.%m.%Y %H:%M')} ({state.get('timezone', DEFAULT_TIMEZONE)})\n"
+                        f"‚úÖ –ü–æ—Å—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω –Ω–∞ {local_time.strftime('%d.%m.%Y %H:%M')} ({state.get('timezone', config.DEFAULT_TIMEZONE)})\n"
                         f"üìù {record['title'][:50]}..."
                     )
                 else:
                     await update.message.reply_text("‚ùå –ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
             else:
                 await update.message.reply_text(
                     "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏\n\n"
                     "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\n"
                     "‚Ä¢ <code>18:30</code>\n"
                     "‚Ä¢ <code>25.12 15:00</code>\n"
                     "‚Ä¢ <code>+2h</code>",
                     parse_mode=ParseMode.HTML
                 )
         
         elif state.get("editing_schedule"):
             # –†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º –≤—Ä–µ–º—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
-            scheduled_time = parse_schedule_time(text)
+            scheduled_time = utils.parse_schedule_time(text)
             if scheduled_time:
                 post_id = state["editing_schedule"]
                 
                 if post_id in state.get("scheduled_posts", {}):
                     state["scheduled_posts"][post_id]["time"] = scheduled_time.isoformat()
                     state["editing_schedule"] = None
                     save_state()
                     
                     local_time = localize_datetime(scheduled_time)
                     await update.message.reply_text(
-                        f"‚úÖ –í—Ä–µ–º—è –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ {local_time.strftime('%d.%m.%Y %H:%M')} ({state.get('timezone', DEFAULT_TIMEZONE)})"
+                        f"‚úÖ –í—Ä–µ–º—è –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ {local_time.strftime('%d.%m.%Y %H:%M')} ({state.get('timezone', config.DEFAULT_TIMEZONE)})"
                     )
                 else:
                     await update.message.reply_text("‚ùå –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
             else:
                 await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏")
         
         elif state.get("waiting_for_prompt"):
             # –û–∂–∏–¥–∞–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç
             uid = state["waiting_for_prompt"]
             record = state["pending"].get(uid)
             
             if record:
                 await update.message.reply_text("üé® –ì–µ–Ω–µ—Ä–∏—Ä—É—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –≤–∞—à–∏–º –æ–ø–∏—Å–∞–Ω–∏–µ–º...")
                 
                 # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                 image_url = await generate_image(text, "creative")
                 
                 if image_url:
                     # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                     if uid not in state["generated_images"]:
                         state["generated_images"][uid] = []
                     
                     state["generated_images"][uid].append(image_url)
                     state["waiting_for_prompt"] = None
                     save_state()
@@ -2342,90 +1435,90 @@ async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE
                 else:
                     await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
             else:
                 await update.message.reply_text("‚ùå –ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
                 
         elif state.get("auto_interval_custom"):
             # –û–∂–∏–¥–∞–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
             try:
                 minutes = int(text)
                 if 10 <= minutes <= 1440:  # –û—Ç 10 –º–∏–Ω—É—Ç –¥–æ 24 —á–∞—Å–æ–≤
                     state["publish_interval"] = minutes * 60
                     state["auto_interval_custom"] = False
                     save_state()
                     await update.message.reply_text(f"‚úÖ –ò–Ω—Ç–µ—Ä–≤–∞–ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {minutes} –º–∏–Ω—É—Ç")
                 else:
                     await update.message.reply_text("‚ùå –ò–Ω—Ç–µ—Ä–≤–∞–ª –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 10 –¥–æ 1440 –º–∏–Ω—É—Ç")
             except ValueError:
                 await update.message.reply_text("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç")
         
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –≤ handle_text_message: {e}")
 
 async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """–û—Ç–º–µ–Ω–∞ —Ç–µ–∫—É—â–µ–π –æ–ø–µ—Ä–∞—Ü–∏–∏"""
     user_id = update.message.from_user.id
-    if ADMIN_CHAT_ID and user_id != ADMIN_CHAT_ID:
+    if config.ADMIN_CHAT_ID and user_id != config.ADMIN_CHAT_ID:
         return
     
     cancelled = []
     
     if state.get("waiting_for_schedule"):
         state["waiting_for_schedule"] = None
         cancelled.append("–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞")
     
     if state.get("editing_schedule"):
         state["editing_schedule"] = None
         cancelled.append("–∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è")
     
     if state.get("waiting_for_image"):
         state["waiting_for_image"] = None
         cancelled.append("–æ–∂–∏–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
     
     if state.get("waiting_for_prompt"):
         state["waiting_for_prompt"] = None
         cancelled.append("–æ–∂–∏–¥–∞–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞")
     
     if state.get("auto_interval_custom"):
         state["auto_interval_custom"] = False
         cancelled.append("—É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞")
     
     if state.get("waiting_for_channel"):
         state["waiting_for_channel"] = False
         cancelled.append("–∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞")
     
     save_state()
     
     if cancelled:
         await update.message.reply_text(f"‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ: {', '.join(cancelled)}")
     else:
         await update.message.reply_text("‚ùå –ù–µ—á–µ–≥–æ –æ—Ç–º–µ–Ω—è—Ç—å")
 
 # –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –º–µ–Ω—é
 async def show_main_menu(query):
     """–ü–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
-    is_admin = not ADMIN_CHAT_ID or query.from_user.id == ADMIN_CHAT_ID
+    is_admin = not config.ADMIN_CHAT_ID or query.from_user.id == config.ADMIN_CHAT_ID
     
     keyboard_buttons = [
         [InlineKeyboardButton("üìä –°—Ç–∞—Ç—É—Å –±–æ—Ç–∞", callback_data="cmd_status")],
         [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="cmd_help")]
     ]
     
     if is_admin:
         keyboard_buttons.extend([
             [
                 InlineKeyboardButton("üëÅ –ü—Ä–µ–≤—å—é –ø–æ—Å—Ç–æ–≤", callback_data="cmd_preview"),
                 InlineKeyboardButton("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–ª–∏–∑—ã", callback_data="cmd_check")
             ],
             [
                 InlineKeyboardButton("üí≠ –°–æ–∑–¥–∞—Ç—å –º—ã—Å–ª–∏", callback_data="cmd_thoughts"),
                 InlineKeyboardButton("‚è∞ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ", callback_data="cmd_scheduled")
             ],
             [
                 InlineKeyboardButton("üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="cmd_stats"),
                 InlineKeyboardButton("ü§ñ –ê–≤—Ç–æ-–ø—É–±–ª–∏–∫–∞—Ü–∏—è", callback_data="cmd_auto_menu")
             ],
             [
                 InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="cmd_settings"),
                 InlineKeyboardButton("üßπ –û—á–∏—Å—Ç–∫–∞", callback_data="cmd_clean_menu")
             ],
             [
@@ -2468,52 +1561,52 @@ async def show_help_info(query):
         "‚Ä¢ Hypebeast\n"
         "‚Ä¢ Highsnobiety\n\n"
         "ü§ñ <b>–ò–ò —Ñ—É–Ω–∫—Ü–∏–∏:</b>\n"
         "‚Ä¢ GPT-4 –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ–∫—Å—Ç–æ–≤\n"
         "‚Ä¢ DALL-E 3 –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –æ–±–ª–æ–∂–µ–∫\n"
         "‚Ä¢ GPT-4 Vision –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n\n"
         "üè∑ <b>–°–∏—Å—Ç–µ–º–∞ —Ç–µ–≥–æ–≤:</b>\n"
         "‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –±—Ä–µ–Ω–¥–æ–≤\n"
         "‚Ä¢ –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–µ–π\n"
         "‚Ä¢ –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º\n\n"
         "üí¨ –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Å–æ–∑–¥–∞—Ç–µ–ª—é –±–æ—Ç–∞"
     )
     
     keyboard = InlineKeyboardMarkup([
         [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="cmd_back_main")]
     ])
     
     await query.edit_message_text(
         help_text,
         parse_mode=ParseMode.HTML,
         reply_markup=keyboard
     )
 
 async def show_settings_menu(query):
     """–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
-    current_channel = state.get("channel", TELEGRAM_CHANNEL)
-    current_timezone = state.get("timezone", DEFAULT_TIMEZONE)
+    current_channel = state.get("channel", config.TELEGRAM_CHANNEL)
+    current_timezone = state.get("timezone", config.DEFAULT_TIMEZONE)
     
     settings_text = (
         "‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞</b>\n\n"
         f"üì¢ –ö–∞–Ω–∞–ª –ø—É–±–ª–∏–∫–∞—Ü–∏–∏: <code>{current_channel}</code>\n"
         f"üïê –í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–æ–Ω–∞: {current_timezone}\n"
         f"üìÖ –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è: {datetime.now(pytz.timezone(current_timezone)).strftime('%H:%M')}\n"
     )
     
     keyboard = InlineKeyboardMarkup([
         [InlineKeyboardButton("üì¢ –ò–∑–º–µ–Ω–∏—Ç—å –∫–∞–Ω–∞–ª", callback_data="settings_channel")],
         [InlineKeyboardButton("üïê –ò–∑–º–µ–Ω–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—É—é –∑–æ–Ω—É", callback_data="settings_timezone")],
         [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="cmd_back_main")]
     ])
     
     await query.edit_message_text(
         settings_text,
         parse_mode=ParseMode.HTML,
         reply_markup=keyboard
     )
 
 async def show_timezone_menu(query):
     """–ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –∑–æ–Ω—ã"""
     timezones = [
         ("üá∑üá∫ –ú–æ—Å–∫–≤–∞", "Europe/Moscow"),
         ("üá∑üá∫ –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥", "Europe/Moscow"),
@@ -2664,111 +1757,111 @@ async def start_preview_mode(query, context):
             )
         
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –≤ start_preview_mode: {e}")
         try:
             await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–µ–≤—å—é")
         except:
             await query.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–µ–≤—å—é")
 
 async def show_status_info(query):
     """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å –±–æ—Ç–∞"""
     try:
         pending_count = len(state["pending"])
         sent_count = len(state["sent_links"])
         scheduled_count = len(state.get("scheduled_posts", {}))
         
         # –°–ª–µ–¥—É—é—â–∏–π –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Å—Ç
         next_scheduled = None
         if state.get("scheduled_posts"):
             next_post = min(
                 state["scheduled_posts"].items(),
                 key=lambda x: x[1]["time"]
             )
             next_time = datetime.fromisoformat(next_post[1]["time"].replace('Z', '+00:00'))
             local_time = localize_datetime(next_time)
-            next_scheduled = f"‚è∞ –°–ª–µ–¥—É—é—â–∏–π –ø–æ—Å—Ç: {local_time.strftime('%d.%m %H:%M')} ({state.get('timezone', DEFAULT_TIMEZONE)})"
+            next_scheduled = f"‚è∞ –°–ª–µ–¥—É—é—â–∏–π –ø–æ—Å—Ç: {local_time.strftime('%d.%m %H:%M')} ({state.get('timezone', config.DEFAULT_TIMEZONE)})"
         
         # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 3 –ø–æ—Å—Ç–∞
         recent_posts = sorted(
             state["pending"].values(),
             key=lambda x: x.get("timestamp", ""),
             reverse=True
         )[:3]
         
         status_text = (
             f"üìä <b>–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞:</b>\n\n"
             f"üìù –ü–æ—Å—Ç–æ–≤ –≤ –æ–∂–∏–¥–∞–Ω–∏–∏: {pending_count}\n"
             f"‚è∞ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ: {scheduled_count}\n"
             f"‚úÖ –û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ: {sent_count}\n"
-            f"üì¢ –ö–∞–Ω–∞–ª: <code>{state.get('channel', TELEGRAM_CHANNEL)}</code>\n"
+            f"üì¢ –ö–∞–Ω–∞–ª: <code>{state.get('channel', config.TELEGRAM_CHANNEL)}</code>\n"
         )
         
         if next_scheduled:
             status_text += f"\n{next_scheduled}\n"
         
         if recent_posts:
             status_text += "\nüÜï <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ—Å—Ç—ã:</b>\n"
             for post in recent_posts:
                 emoji = "üëü" if post.get("category") == "sneakers" else "üëî"
-                date = format_date_for_display(post.get("timestamp", ""))
+                date = utils.format_date_for_display(post.get("timestamp", ""))
                 status_text += f"{emoji} {date} - {post['title'][:40]}...\n"
         
         keyboard = InlineKeyboardMarkup([
             [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="cmd_back_main")]
         ])
         
         await query.edit_message_text(
             status_text,
             parse_mode=ParseMode.HTML,
             reply_markup=keyboard
         )
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –≤ show_status_info: {e}")
         await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
 
 async def show_scheduled_posts(query):
     """–ü–æ–∫–∞–∑–∞—Ç—å –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ—Å—Ç—ã —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è"""
     try:
         scheduled = state.get("scheduled_posts", {})
         
         if not scheduled:
             text = "üì≠ <b>–ù–µ—Ç –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ—Å—Ç–æ–≤</b>"
             keyboard = InlineKeyboardMarkup([
                 [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="cmd_back_main")]
             ])
         else:
             text = "üìÖ <b>–ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ—Å—Ç—ã:</b>\n\n"
             keyboard_buttons = []
             
             for post_id, info in sorted(scheduled.items(), key=lambda x: x[1]["time"]):
                 scheduled_time = datetime.fromisoformat(info["time"].replace('Z', '+00:00'))
                 local_time = localize_datetime(scheduled_time)
                 record = info["record"]
                 
                 text += (
-                    f"‚è∞ {local_time.strftime('%d.%m %H:%M')} ({state.get('timezone', DEFAULT_TIMEZONE)})\n"
+                    f"‚è∞ {local_time.strftime('%d.%m %H:%M')} ({state.get('timezone', config.DEFAULT_TIMEZONE)})\n"
                     f"üìù {record['title'][:50]}...\n"
                     f"üìç {record.get('source', 'Unknown')}\n\n"
                 )
                 
                 # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ—Å—Ç–∞
                 keyboard_buttons.append([
                     InlineKeyboardButton("‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å", callback_data=f"edit_schedule:{post_id}"),
                     InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_schedule:{post_id}")
                 ])
             
             keyboard_buttons.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="cmd_back_main")])
             keyboard = InlineKeyboardMarkup(keyboard_buttons)
         
         await query.edit_message_text(
             text,
             parse_mode=ParseMode.HTML,
             reply_markup=keyboard
         )
         
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –≤ show_scheduled_posts: {e}")
         await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
 
 async def show_auto_publish_menu(query):
     """–ú–µ–Ω—é –∞–≤—Ç–æ-–ø—É–±–ª–∏–∫–∞—Ü–∏–∏"""
@@ -2976,106 +2069,106 @@ async def test_sources_inline(query, context):
                     
                 except Exception as e:
                     results.append(f"‚ùå {src['name']}: {type(e).__name__}")
             
             # –§–æ—Ä–º–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
             final_text = "üìä <b>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:</b>\n\n" + "\n\n".join(results)
             
             keyboard = InlineKeyboardMarkup([
                 [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="cmd_back_main")]
             ])
             
             await query.edit_message_text(
                 final_text,
                 parse_mode=ParseMode.HTML,
                 reply_markup=keyboard
             )
         
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –≤ test_sources_inline: {e}")
         await query.edit_message_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
 
 async def reset_state_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
     """–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è —Å–±—Ä–æ—Å–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∞)"""
     try:
         user_id = update.message.from_user.id
-        if ADMIN_CHAT_ID and user_id != ADMIN_CHAT_ID:
+        if config.ADMIN_CHAT_ID and user_id != config.ADMIN_CHAT_ID:
             await update.message.reply_text("‚ùå –≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É")
             return
         
         # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ —á–∏—Å—Ç–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
         global state
         state = {
             "sent_links": [], 
             "pending": {}, 
             "moderation_queue": [], 
             "preview_mode": {}, 
             "thoughts_mode": False,
             "scheduled_posts": {},
             "generated_images": {},
             "waiting_for_image": None,
             "current_thought": None,
             "waiting_for_schedule": None,
             "editing_schedule": None,
             "favorites": [],
             "auto_publish": False,
             "publish_interval": 3600,
-            "timezone": DEFAULT_TIMEZONE,
-            "channel": TELEGRAM_CHANNEL,
+            "timezone": config.DEFAULT_TIMEZONE,
+            "channel": config.TELEGRAM_CHANNEL,
             "waiting_for_channel": False
         }
         save_state()
         
         await update.message.reply_text(
             "‚úÖ –°–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—Ç–∞ —Å–±—Ä–æ—à–µ–Ω–æ!\n\n"
             "–í—Å–µ –ø–æ—Å—Ç—ã –æ—á–∏—â–µ–Ω—ã. –ó–∞–ø—É—Å—Ç–∏—Ç–µ /check –¥–ª—è –ø–æ–∏—Å–∫–∞ –Ω–æ–≤—ã—Ö —Ä–µ–ª–∏–∑–æ–≤."
         )
         
     except Exception as e:
         logging.error(f"–û—à–∏–±–∫–∞ –≤ reset_state_command: {e}")
         await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è")
 
 def main() -> None:
     try:
-        app = Application.builder().token(TELEGRAM_TOKEN).connect_timeout(30).read_timeout(30).build()
+        app = Application.builder().token(config.TELEGRAM_TOKEN).connect_timeout(30).read_timeout(30).build()
         
         # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
         app.add_handler(CommandHandler("start", start_command))
         app.add_handler(CommandHandler("cancel", cancel_command))
         app.add_handler(CommandHandler("thoughts", thoughts_command))
         app.add_handler(CommandHandler("skip", skip_command))
         app.add_handler(CommandHandler("reset_state", reset_state_command))
         
         # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —Ñ–æ—Ç–æ –∏ —Ç–µ–∫—Å—Ç–∞
         app.add_handler(MessageHandler(filters.PHOTO, handle_photo))
         app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))
         
         # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ callback
         app.add_handler(CallbackQueryHandler(on_callback))
         
         # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫—É—é –ø—Ä–æ–≤–µ—Ä–∫—É
         app.job_queue.run_repeating(
             check_releases_job,
-            interval=CHECK_INTERVAL_SECONDS,
+            interval=config.CHECK_INTERVAL_SECONDS,
             first=30
         )
         
         logging.info("=== HypeBot –∑–∞–ø—É—â–µ–Ω ===")
-        logging.info(f"Admin ID: {ADMIN_CHAT_ID if ADMIN_CHAT_ID else '–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}")
-        logging.info(f"Channel: {state.get('channel', TELEGRAM_CHANNEL)}")
-        logging.info(f"Timezone: {state.get('timezone', DEFAULT_TIMEZONE)}")
+        logging.info(f"Admin ID: {config.ADMIN_CHAT_ID if config.ADMIN_CHAT_ID else '–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}")
+        logging.info(f"Channel: {state.get('channel', config.TELEGRAM_CHANNEL)}")
+        logging.info(f"Timezone: {state.get('timezone', config.DEFAULT_TIMEZONE)}")
         logging.info(f"–ò—Å—Ç–æ—á–Ω–∏–∫–æ–≤: {len(SOURCES)}")
         logging.info("–ù–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏: –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞–Ω–∞–ª–∞, –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∑–æ–Ω—ã, —É–ª—É—á—à–µ–Ω–Ω—ã–µ –ø—Ä–æ–º–ø—Ç—ã")
         
         try:
             app.run_polling(drop_pending_updates=True, allowed_updates=Update.ALL_TYPES)
         except Conflict:
             logging.critical("–ë–æ—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω –≤ –¥—Ä—É–≥–æ–º –ø—Ä–æ—Ü–µ—Å—Å–µ.")
             return
     except Exception as e:
         logging.critical(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {e}")
         import traceback
         traceback.print_exc()
         exit(1)
 
 if __name__ == "__main__":
-    main()
\ No newline at end of file
+    main()
